taskKey="com.javarush.task.task33.task3310.big15"\n\nShortener (15)

Напишем еще один тест, который проверит, что получить идентификатор для строки
используя стратегию HashBiMapStorageStrategy можно быстрее, чем используя
стратегию HashMapStorageStrategy.
15.1.	Создай класс SpeedTest в пакете tests.
15.2.	Добавь в класс метод long getTimeToGetIds(Shortener shortener, Set&lt;String&gt;
strings, Set&lt;Long&gt; ids). Он должен возвращать время в миллисекундах необходимое
для получения идентификаторов для всех строк из strings. Идентификаторы
должны быть записаны в ids.
15.3.	Добавь в класс метод long getTimeToGetStrings(Shortener shortener,
Set&lt;Long&gt; ids, Set&lt;String&gt; strings). Он должен возвращать время в миллисекундах
необходимое для получения строк для всех идентификаторов из ids. Строки
должны быть записаны в strings.
15.4.	Добавь в класс SpeedTest тест testHashMapStorage(). Он должен:
15.4.1.	Создавать два объекта типа Shortener, один на базе
HashMapStorageStrategy, второй на базе HashBiMapStorageStrategy. Назовем
их shortener1 и shortener2.
15.4.2.	Генерировать с помощью Helper 10000 строк и помещать их в сет со
строками, назовем его origStrings.
15.4.3.	Получать время получения идентификаторов для origStrings (вызывать
метод getTimeToGetIds для shortener1, а затем для shortener2).
15.4.4.	Проверять с помощью junit, что время, полученное в предыдущем пункте
для shortener1 больше, чем для shortener2.
15.4.5.	Получать время получения строк (вызывать метод getTimeToGetStrings
для shortener1 и shortener2).
15.4.6.	Проверять с помощью junit, что время, полученное в предыдущем пункте
для shortener1 примерно равно времени для shortener2. Используй метод
assertEquals(float expected, float actual, float delta). В качестве delta можно
использовать 30, этого вполне достаточно для наших экспериментов.


Требования:
1.	Метод getTimeToGetStrings должен возвращать время в миллисекундах необходимое для получения всех строк для множества идентификаторов ids.
2.	Метод getTimeToGetIds должен возвращать время в миллисекундах необходимое для получения всех идентификаторов для множества строк strings.
3.	В методе testHashMapStorage должно быть выполнено сравнение времени получения множества ключей и множества значений для стратегий HashMapStorageStrategy и HashBiMapStorageStrategy.


Shortener (15)

Мы много раз тестировали наши стратегии с помощью метода testStrategy() класса
Solution. Пришло время написать настоящие юнит тесты с использованием junit.
14.1.	Прочитай что такое юнит тесты.
14.2.	Скачай и подключи библиотеку Junit 4.12. Разберись как ей пользоваться.
Библиотека Junit зависит от библиотеки hamcrest-core. Подключи и ее. Используй версию 1.3.
14.3.	Добавь класс FunctionalTest в пакет tests. В этом классе мы проверим
функциональность наших стратегий.
14.4.	Добавь в класс FunctionalTest метод testStorage(Shortener shortener). Он
должен:
14.4.1.	Создавать три строки. Текст 1 и 3 строк должен быть одинаковым.
14.4.2.	Получать и сохранять идентификаторы для всех трех строк с помощью
shortener.
14.4.3.	Проверять, что идентификатор для 2 строки не равен идентификатору для 1
и 3 строк. Подсказка: метод Assert.assertNotEquals.
14.4.4.	Проверять, что идентификаторы для 1 и 3 строк равны. Подсказка: метод
Assert.assertEquals.
14.4.5.	Получать три строки по трем идентификаторам с помощью shortener.
14.4.6.	Проверять, что строки, полученные в предыдущем пункте, эквивалентны
оригинальным. Подсказка: метод Assert.assertEquals.
14.5.	Добавь в класс FunctionalTest тесты:
14.5.1.	testHashMapStorageStrategy()
14.5.2.	testOurHashMapStorageStrategy()
14.5.3.	testFileStorageStrategy()
14.5.4.	testHashBiMapStorageStrategy()
14.5.5.	testDualHashBidiMapStorageStrategy()
14.5.6.	testOurHashBiMapStorageStrategy()
Каждый тест должен иметь аннотацию @Test, создавать подходящую стратегию,
создавать объект класса Shortener на базе этой стратегии и вызывать метод
testStorage для него.
Запусти и проверь, что все тесты проходят.




Shortener (15)

Рассмотрим еще одну реализацию BiMap, на этот раз из Apache Commons Collections.
13.1.	Скачай и подключи Apache Commons Collections 4.0.
13.2.	Реализуй стратегию DualHashBidiMapStorageStrategy. Она должна:
13.2.1.	Поддерживать интерфейс StorageStrategy.
13.2.2.	Внутри иметь только одно поле data с типом DualHashBidiMap.
13.3.	Проверь новую стратегию в методе main(). Запусти программу и сравни
скорость работы шести стратегий.



Shortener (15)

Задача, когда требуется создать Map, работающий в две стороны (по ключу получать
значение, а по значению ключ) не такая уж и редкая. Такие коллекции уже
реализованы в различных сторонних библиотеках коллекций. Одна из таких Guava от
Google.
12.1.	Скачай и подключи библиотеку guava версии 19.0.
12.2.	Реализуй стратегию HashBiMapStorageStrategy. Она должна:
12.2.1.	Поддерживать интерфейс StorageStrategy.
12.2.2.	Внутри иметь только одно поле data типа HashBiMap.
12.3.	Проверь новую стратегию в методе main(). Запусти программу и сравни
скорость работы пяти стратегий.



Shortener (15)

Как ты заметил, получение идентификатора для строки требует намного больше
времени, чем получение строки по идентификатору. Это ожидаемо и следует из
реализации HashMap. Давай напишем четвертую стратегию
OurHashBiMapStorageStrategy, которая будет лишена этого недостатка.
11.1.	Создай класс OurHashBiMapStorageStrategy, реализующий интерфейс
StorageStrategy.
11.2.	Добавь в него два поля HashMap&lt;Long, String&gt; k2v и HashMap&lt;String, Long&gt; v2k.
Первое будет хранить соответствие ключа и значения, а второе наоборот: значения
и ключа.
11.3.	Реализуй методы интерфейса StorageStrategy, обеспечив максимальную
скорость. Подсказка: при добавлении новой пары ключ-значение необходимо
добавлять ее сразу в два поля.
Проверь новую стратегию в методе main(). Запусти программу и сравни скорость работы
всех 4х стратегий. Убедись, что мы значительно увеличили скорость получения
идентификатора. Но как ты понимаешь, у этого решения есть не только плюсы, но и минусы.
Подумай в каких случаях имеет смысл использовать OurHashBiMapStorageStrategy, а в каких
HashMapStorageStrategy.



Shortener (15)

Создай и реализуй класс FileStorageStrategy. Он должен:
10.1.	Реализовывать интерфейс StorageStrategy.
10.2.	Использовать FileBucket в качестве ведер (англ. bucket). Подсказка: класс
должен содержать поле FileBucket[] table.
10.3.	Работать аналогично тому, как это делает OurHashMapStorageStrategy, но
удваивать количество ведер не когда количество элементов size станет больше
какого-то порога, а когда размер одного из ведер (файлов) стал больше
bucketSizeLimit.
10.3.1.	Добавь в класс поле long bucketSizeLimit.
10.3.2.	Проинициализируй его значением по умолчанию, например, 10000 байт.
10.3.3.	Добавь сеттер и геттер для этого поля.
10.4.	При реализации метода resize(int newCapacity) проследи, чтобы уже не нужные
файлы были удалены (вызови метод  remove()).
Проверь новую стратегию в методе main(). Учти, что стратегия FileStorageStrategy гораздо
более медленная, чем остальные. Не используй большое количество элементов для теста,
это может занять оооочень много времени.
Запусти программу и сравни скорость работы всех 3х стратегий.

P.S. Обрати внимание на наличие всех необходимых полей в классе FileStorageStrategy, по аналогии с OurHashMapStorageStrategy:
static final int DEFAULT_INITIAL_CAPACITY
static final long DEFAULT_BUCKET_SIZE_LIMIT
FileBucket[] table
int size
private long bucketSizeLimit = DEFAULT_BUCKET_SIZE_LIMIT
long maxBucketSize



