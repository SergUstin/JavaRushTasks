taskKey="com.javarush.task.task33.task3310.big14"\n\nShortener (14)

Мы много раз тестировали наши стратегии с помощью метода testStrategy() класса
Solution. Пришло время написать настоящие юнит тесты с использованием junit.
14.1.	Прочитай что такое юнит тесты.
14.2.	Скачай и подключи библиотеку Junit 4.12. Разберись как ей пользоваться.
Библиотека Junit зависит от библиотеки hamcrest-core. Подключи и ее. Используй версию 1.3.
14.3.	Добавь класс FunctionalTest в пакет tests. В этом классе мы проверим
функциональность наших стратегий.
14.4.	Добавь в класс FunctionalTest метод testStorage(Shortener shortener). Он
должен:
14.4.1.	Создавать три строки. Текст 1 и 3 строк должен быть одинаковым.
14.4.2.	Получать и сохранять идентификаторы для всех трех строк с помощью
shortener.
14.4.3.	Проверять, что идентификатор для 2 строки не равен идентификатору для 1
и 3 строк. Подсказка: метод Assert.assertNotEquals.
14.4.4.	Проверять, что идентификаторы для 1 и 3 строк равны. Подсказка: метод
Assert.assertEquals.
14.4.5.	Получать три строки по трем идентификаторам с помощью shortener.
14.4.6.	Проверять, что строки, полученные в предыдущем пункте, эквивалентны
оригинальным. Подсказка: метод Assert.assertEquals.
14.5.	Добавь в класс FunctionalTest тесты:
14.5.1.	testHashMapStorageStrategy()
14.5.2.	testOurHashMapStorageStrategy()
14.5.3.	testFileStorageStrategy()
14.5.4.	testHashBiMapStorageStrategy()
14.5.5.	testDualHashBidiMapStorageStrategy()
14.5.6.	testOurHashBiMapStorageStrategy()
Каждый тест должен иметь аннотацию @Test, создавать подходящую стратегию,
создавать объект класса Shortener на базе этой стратегии и вызывать метод
testStorage для него.
Запусти и проверь, что все тесты проходят.



Требования:
1.	Класс FunctionalTest должен быть добавлен в созданный пакет tests.
2.	В методе testStorage должны быть трижды вызваны методы getId и getString.
3.	Тестовые методы перечисленные в условии задачи должны быть отмечены только аннотацией @Test.
4.	В каждом тестовом методе должен содержаться вызов метода testStorage.


Shortener (14)

Рассмотрим еще одну реализацию BiMap, на этот раз из Apache Commons Collections.
13.1.	Скачай и подключи Apache Commons Collections 4.0.
13.2.	Реализуй стратегию DualHashBidiMapStorageStrategy. Она должна:
13.2.1.	Поддерживать интерфейс StorageStrategy.
13.2.2.	Внутри иметь только одно поле data с типом DualHashBidiMap.
13.3.	Проверь новую стратегию в методе main(). Запусти программу и сравни
скорость работы шести стратегий.



Shortener (14)

Задача, когда требуется создать Map, работающий в две стороны (по ключу получать
значение, а по значению ключ) не такая уж и редкая. Такие коллекции уже
реализованы в различных сторонних библиотеках коллекций. Одна из таких Guava от
Google.
12.1.	Скачай и подключи библиотеку guava версии 19.0.
12.2.	Реализуй стратегию HashBiMapStorageStrategy. Она должна:
12.2.1.	Поддерживать интерфейс StorageStrategy.
12.2.2.	Внутри иметь только одно поле data типа HashBiMap.
12.3.	Проверь новую стратегию в методе main(). Запусти программу и сравни
скорость работы пяти стратегий.



Shortener (14)

Как ты заметил, получение идентификатора для строки требует намного больше
времени, чем получение строки по идентификатору. Это ожидаемо и следует из
реализации HashMap. Давай напишем четвертую стратегию
OurHashBiMapStorageStrategy, которая будет лишена этого недостатка.
11.1.	Создай класс OurHashBiMapStorageStrategy, реализующий интерфейс
StorageStrategy.
11.2.	Добавь в него два поля HashMap&lt;Long, String&gt; k2v и HashMap&lt;String, Long&gt; v2k.
Первое будет хранить соответствие ключа и значения, а второе наоборот: значения
и ключа.
11.3.	Реализуй методы интерфейса StorageStrategy, обеспечив максимальную
скорость. Подсказка: при добавлении новой пары ключ-значение необходимо
добавлять ее сразу в два поля.
Проверь новую стратегию в методе main(). Запусти программу и сравни скорость работы
всех 4х стратегий. Убедись, что мы значительно увеличили скорость получения
идентификатора. Но как ты понимаешь, у этого решения есть не только плюсы, но и минусы.
Подумай в каких случаях имеет смысл использовать OurHashBiMapStorageStrategy, а в каких
HashMapStorageStrategy.



Shortener (14)

Создай и реализуй класс FileStorageStrategy. Он должен:
10.1.	Реализовывать интерфейс StorageStrategy.
10.2.	Использовать FileBucket в качестве ведер (англ. bucket). Подсказка: класс
должен содержать поле FileBucket[] table.
10.3.	Работать аналогично тому, как это делает OurHashMapStorageStrategy, но
удваивать количество ведер не когда количество элементов size станет больше
какого-то порога, а когда размер одного из ведер (файлов) стал больше
bucketSizeLimit.
10.3.1.	Добавь в класс поле long bucketSizeLimit.
10.3.2.	Проинициализируй его значением по умолчанию, например, 10000 байт.
10.3.3.	Добавь сеттер и геттер для этого поля.
10.4.	При реализации метода resize(int newCapacity) проследи, чтобы уже не нужные
файлы были удалены (вызови метод  remove()).
Проверь новую стратегию в методе main(). Учти, что стратегия FileStorageStrategy гораздо
более медленная, чем остальные. Не используй большое количество элементов для теста,
это может занять оооочень много времени.
Запусти программу и сравни скорость работы всех 3х стратегий.

P.S. Обрати внимание на наличие всех необходимых полей в классе FileStorageStrategy, по аналогии с OurHashMapStorageStrategy:
static final int DEFAULT_INITIAL_CAPACITY
static final long DEFAULT_BUCKET_SIZE_LIMIT
FileBucket[] table
int size
private long bucketSizeLimit = DEFAULT_BUCKET_SIZE_LIMIT
long maxBucketSize



Shortener (14)

Напишем еще одну стратегию, назовем ее FileStorageStrategy. Она будет очень похожа
на стратегию OurHashMapStorageStrategy, но в качестве ведер (англ. buckets) будут
файлы. Я знаю, ты знаешь о каких buckets идет речь, если нет &ndash; повтори внутреннее
устройство HashMap.
9.1.	Создай класс FileBucket в пакете strategy.
9.2.	Добавь в класс поле Path path. Это будет путь к файлу.
9.3.	Добавь в класс конструктор без параметров, он должен:
9.3.1.	Инициализировать path временным файлом. Файл должен быть размещен
в директории для временных файлов и иметь случайное имя. Подсказка:
Files.createTempFile.
9.3.2.	Создавать новый файл, используя path. Если такой файл уже есть, то
заменять его.
9.3.3.	Обеспечивать удаление файла при выходе из программы. Подсказка:
deleteOnExit().
9.4.	Добавь в класс методы:
9.4.1.	public long getFileSize(), он должен возвращать размер файла на который
указывает path.
9.4.2.	public void putEntry(Entry entry) - должен сериализовывать переданный entry в
файл. Учти, каждый entry может содержать еще один entry.
9.4.3.	public Entry getEntry() - должен забирать entry из файла. Если файл имеет нулевой
размер, вернуть null.
9.4.4.	public void remove() &ndash; удалять файл на который указывает path.
Конструктор и методы не должны кидать исключения.



