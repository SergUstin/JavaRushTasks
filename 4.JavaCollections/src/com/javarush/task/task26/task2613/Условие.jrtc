taskKey="com.javarush.task.task26.task2613.big15"\n\nCashMachine (15)

1. В CashMachine создай константу - путь к ресурсам.
public static final String RESOURCE_PATH;
Отрефакторь загрузку всех ResourceBundle с учетом RESOURCE_PATH.

2. В классе CashMachine не должно быть инициализации ResourceBundle.
Вынеси из CashMachine сообщение о выходе в ConsoleHelper, назови метод printExitMessage.

3. Это всё! Красоту можешь наводить самостоятельно. Тестов на этот пункт не будет.
Например:
3.1. Исправить выводимые тексты.
3.2. Добавить ресурсы для нескольких локалей. Например, еще и для русской.
3.3. Добавить валидацию вводимых номиналов.

Твои достижения:
1. разобрался с паттерном Command.
2. подружился с Жадным алгоритмом.
3. познакомился с локализацией.
4. стал больше знать и уметь.
5. увидел, как раскладывать задачу на подзадачи.
6. продвинулся на шаг ближе к работе джава программистом.
7. решил одно из тестовых заданий, которое дают на собеседовании. Только тсссс, никому об этом не говори :).
Если когда-то тебе дадут такое задание, то не копируй это решение, а сделай свое по аналогии.

Поздравляю!


Требования:
1.	Класс CashMachine должен содержать public static final поле RESOURCE_PATH типа String.
2.	Класс ConsoleHelper должен содержать public static void метод printExitMessage().
3.	Поздравляю, это все на этот уровень!


CashMachine (15)

1. В LoginCommand, WithdrawCommand добавь поле private ResourceBundle res, которое инициализируй соответствующим ресурсом.
Для LoginCommand ресурс login_en.properties.
Для WithdrawCommand ресурс withdraw_en.properties.

2. Для ресурса common_en.properties замени все строки в ConsoleHelper.
Для этого создай приватное статическое поле ResourceBundle res в классе ConsoleHelper и инициализируй соответствующим ресурсом.
Важно: путь к ресурсам строй динамически, для этого используй у класса CashMachine метод getPackage()




CashMachine (15)

Ты уже разобрался с ResourceBundle - это круто.
Теперь мы сможем прикрутить локализацию, т.е. поддержку нескольких языков.

1. В DepositCommand, ExitCommand, InfoCommand добавь поле private ResourceBundle res, которое инициализируй соответствующим ресурсом.
Для DepositCommand ресурс deposit_en.properties.
Для ExitCommand ресурс exit_en.properties.
Для InfoCommand ресурс info_en.properties.
Важно: путь к ресурсам строй динамически, для этого используй у класса CashMachine метод getPackage()
2. Для каждого нового ресурса замени все строки в соответствующей команде.




CashMachine (15)

В задании 11 мы захардкодили номер кредитной карточки с пином, с которыми разрешим работать нашему банкомату.
Но юзеров может быть много. Не будем же мы их всех хардкодить! Если понадобится добавить еще одного пользователя,
то придется передеплоить наше приложение. Есть решение этой проблемы.

Смотри, добавился новый пакет resources, в котором мы будем хранить наши ресурсные файлы.
В этом пакете есть файл verifiedCards.properties, в котором заданы карточки с пинами.

1. В LoginCommand добавь поле private ResourceBundle validCreditCards.
При объявлении инициализируй это поле данными из файла verifiedCards.properties.
Почитай в инете, как это делается для ResourceBundle.
Важно: путь к ресурсу verifiedCards.properties строй динамически, для этого используй у класса CashMachine метод getPackage()
2. Замени хардкоженные данные кредитной карточки и пина на проверку наличия данных в ресурсе verifiedCards.properties.




CashMachine (15)

Поздравляю, ты реализовал WithdrawCommand! Основной функционал завершен. Дальше можно допиливать и наводить красоту.
Реализуем одну плюшку. Можно и без нее, но с ней - красивее.
Это верификация кредитной карты пользователя. Нет, никакого API сторонних либ не будет. Только консольная обработка.

Итак, назовем эту операцию LOGIN и сделаем для нее команду.
1. Добавь в операции LOGIN с ординал = 0
2. Запрети пользователю выбирать эту операцию из списка.
В единственном методе для поиска операций запрети доступ по ординал - бросим IllegalArgumentException.
3. Создай LoginCommand по аналогии с другими командами, в котором захардкодь номер карточки с пином
123456789012 и 1234 соответственно.
4. Реализуй следующую логику для команды LoginCommand:
4.1. Пока пользователь не введет валидные номер карты и пин - выполнять следующие действия:
4.2. Запросить у пользователя 2 числа - номер кредитной карты, состоящий из 12 цифр, и пин - состоящий из 4 цифр.
4.3. Вывести юзеру сообщение о невалидных данных, если они такими являются.
4.4. Если данные валидны, то проверить их на соответствие захардкоженным (123456789012 и 1234).
4.5. Если данные в п. 4.4. идентифицированы, то сообщить, что верификация прошла успешно.
4.6. Если данные в п. 4.4. НЕ идентифицированы, то вернуться к п.4.1.
5. Исправь CommandExecutor. Добавь в allKnownCommandsMap новую операцию.
6. Исправь метод main.
Операция LOGIN должна запускаться один раз, до выполнения всех операций.
Не забудь о InterruptOperationException, в любом месте пользователь может завершить работу с банкоматом. Поэтому добавь вызов операции внутрь блока try-catch.




CashMachine (15)

Сегодня мы займемся командой WithdrawCommand - это самая сложная операция.

1. Реализуй следующий алгоритм для команды WithdrawCommand:
1.1. Считать код валюты (метод уже есть).
1.2. Получить манипулятор для этой валюты.
1.3. Пока пользователь не введет корректные данные выполнять:
1.3.1. Попросить ввести сумму.
1.3.2. Если введены некорректные данные, то сообщить об этом пользователю и вернуться к п. 1.3.
1.3.3. Проверить, достаточно ли средств на счету.
Для этого в манипуляторе создай метод boolean isAmountAvailable(int expectedAmount), который вернет true, если денег достаточно для выдачи.
Если недостаточно, то вернуться к п. 1.3.
1.3.4. Списать деньги со счета. Для этого в манируляторе создай метод
Map&lt;Integer, Integer&gt; withdrawAmount(int expectedAmount), который вернет карту HashMap&lt;номинал, количество&gt;.
Подробно логику этого метода смотри в п.2.
1.3.5. Вывести пользователю результат из п. 1.3.4. в следующем виде:
&lt;табуляция&gt;номинал - количество.
Сортировка - от большего номинала к меньшему.
Вывести сообщение об успешной транзакции.
1.3.6. Перехватить исключение NotEnoughMoneyException, уведомить юзера о нехватке банкнот и вернуться к п. 1.3.

2. Логика основного метода withdrawAmount:
2.1. Внимание!!! Метод withdrawAmount должен возвращать минимальное количество банкнот, которыми набирается запрашиваемая сумма.
Используй Жадный алгоритм (use google).
Если есть несколько вариантов, то использовать тот, в котором максимальное количество банкнот высшего номинала.
Если для суммы 600 результат - три банкноты: 500 + 50 + 50 = 200 + 200 + 200, то выдать первый вариант.
Пример, надо выдать 600.
В манипуляторе есть следующие банкноты:
500 - 2
200 - 3
100 - 1
50 - 12
Результат должен быть таким:
500 - 1
100 - 1
т.е. всего две банкноты (это минимальное количество банкнот) номиналом 500 и 100.

2.2. Мы же не можем одни и те же банкноты выдавать несколько раз, поэтому
если мы нашли вариант выдачи денег (п.2.1. успешен), то вычесть все эти банкноты из карты в манипуляторе.

2.3. метод withdrawAmount должен кидать NotEnoughMoneyException, если купюрами невозможно выдать запрашиваемую сумму.
Пример, надо выдать 600.
В манипуляторе есть следующие банкноты:
500 - 2
200 - 2
Результат - данными банкнотами невозможно выдать запрашиваемую сумму. Кинуть исключение.
Не забудь, что в некоторых случаях картой кидается ConcurrentModificationException.



