taskKey="com.javarush.task.task34.task3410.big09"\n\nSokoban (9)

В процессе работы игры, будут возникать различные события. Давай создадим интерфейс
слушателя событий EventListener. Его должен реализовывать каждый класс, который хочет
обрабатывать события. А классы, которые будут генерировать события, будут вызывать
методы этого интерфейса.
9.1. Добавь интерфейс EventListener в пакет controller.
9.2. Добавь в интерфейс void методы:
9.2.1. move(Direction direction) &ndash; передвинуть объект в определенном направлении.
9.2.2. restart() &ndash; начать заново текущий уровень.
9.2.3. startNextLevel() &ndash; начать следующий уровень.
9.2.4. levelCompleted(int level) &ndash; уровень с номером level завершён.
9.3. Добавь классу Controller интерфейс EventListener, напиши необходимые заглушки-
реализации интерфейса.
9.4. Добавь в классы Model и Field по полю EventListener eventListener.
9.5. Добавь в классы Model, View и Field по методу setEventListener(EventListener
eventListener). Этот метод в классе View должен вызвать аналогичный метод у объекта
field, а в классах Model и Field устанавливать значение внутренних полей eventListener.


Требования:
1.	Добавь интерфейс EventListener в пакет controller.
2.	Добавь в интерфейс EventListener void методы: move(Direction direction), restart(), startNextLevel() и levelCompleted(int level).
3.	Добавь классу Controller интерфейс EventListener, напиши необходимые заглушки-реализации интерфейса.
4.	Добавь в классы Model и Field по полю EventListener eventListener.
5.	Реализуй в классах Model, View и Field методы setEventListener(EventListener eventListener).


Sokoban (9)

Ты создал полную коллекцию типов игровых объектов. Давай создадим класс, который будет хранить эти объекты.
8.1. Создай класс GameObjects в пакте model.
8.2. Добавь в него:
8.2.1. Поля Set&lt;Wall&gt; walls, Set&lt;Box&gt; boxes, Set&lt;Home&gt; homes и Player player.
8.2.2. Геттеры для этих полей.
8.2.3. Конструктор класса, принимающий Set&lt;Wall&gt; walls, Set &lt;Box&gt; boxes, Set&lt;Home&gt; homes,
Player player и инициализирующий поля класса.
8.2.4. Метод Set&lt;GameObject&gt; getAll(). Он должен возвращать множество, содержащее
все объекты, хранящиеся внутри класса.



Sokoban (9)

Давай сделаем класс стены Wall. Стена может сталкиваться с другими объектами, но не
может двигаться.
7.1. Добавь класс Wall в пакет model.
7.2. Унаследуй класс от подходящего родителя.
7.3. Реализуй конструктор с параметрами int x и int y.
7.4. Реализуй метод отрисовки.
Подсказка: стену можно нарисовать залитым квадратом коричневого цвета, но тебя
никто не ограничивает в выборе цвета, прояви свою творческую суть по полной.



Sokoban (9)

Пришло время создать класс Home. Этот класс будет отвечать за места на игровом поле
(дома) в которые нужно сдвинуть все ящики. Объекты этого типа не должны передвигаться
по полю или сталкиваться с другими игровыми объектами.
6.1. Добавь в пакет model класс Home.
6.2. Класс должен быть унаследован от максимально подходящего базового класса.
6.3. Добавь в созданный класс конструктор, принимающий int x и int y. Высота и ширина
дома должны быть равны 2.
6.4. Реализуй метод отрисовки дома. Подсказка: можешь использовать красный цвет и
прозрачный круг.

Как и с предыдущими игровыми объектами, можешь проверить метод отрисовки в методе
paint() класса Field.



Sokoban (9)

Игровые объекты &ldquo;Ящик&rdquo; и &ldquo;Игрок&rdquo; с одной стороны являются объектами, которые могут
сталкиваться, а с другой они могут перемещаться по полю.
5.1. Создай класс игрока Player и класс ящика Box в пакете model. Каждый из них
унаследуй от максимально подходящего класса.
5.2. Созданные классы должны поддерживать интерфейс, отвечающий за движение
объектов.
5.3. Добавь в созданные классы конструкторы, принимающие int x и int y.
5.4. В каждом из классов, реализуй метод, отвечающий за движение. Он должен смещать
координаты объектов (x и y) на переданные значения.
5.5. В каждом из них, реализуй метод, отвечающий за отрисовку. Этот метод должен:
устанавливать какой-то цвет и рисовать какие-то примитивные фигуры. Проследи,
чтобы центр фигуры имел координаты x и y, а высота и ширина соответствовали
значениям полей height и width.
Подсказка: игрока можешь нарисовать желтым залитым кругом, а ящик &ndash; оранжевым
квадратом с прорисованными диагоналями. Это пример, ты можешь сам выбрать цвет
и вид каждого объекта, ты ограничен только методами доступными для Graphics и
своей фантазией.

Для того чтобы проверить как рисуется твой ящик или игрок, ты можешь создать
объект типа Box или Player в методе paint() класса Field и вызвать у объекта метод
draw(). Сделай это исключительно для проверки методов draw(), в дальнейшем метод
paint() мы реализуем иначе.



Sokoban (9)

Общий класс игровых объектов GameObject уже есть. Пришло время создать классы конкретных типов игровых объектов.
4.1. Часть игровых объектов могут двигаться (игрок и ящики), а часть нет, например, стены и дома.
4.1.1. Добавь интерфейс Movable в пакет model.
4.1.2. Интерфейс Movable должен иметь метод void move(int x, int y).
4.2. Добавь enum Direction в пакет model. Он должен содержать следующие значения:
LEFT, RIGHT, UP и DOWN. Этот тип будет использоваться для описания направления движения объектов.
4.3. Игровые объекты типа &ldquo;дом&rdquo; не поддерживают логики столкновений (игрок или
ящики могут свободно передвигаться по ним). Что касается остальных объектов, то
они не должны проходить сквозь друг друга, они должны сталкиваться. Например,
ящик нельзя протолкнуть сквозь стену.
4.3.1. Добавь абстрактный класс CollisionObject в пакет model.
4.3.2. Класс CollisionObject должен быть унаследован от GameObject.
4.3.3. Добавь в класс CollisionObject:
4.3.3.1. Конструктор, принимающий int x и int y.
4.3.3.2. Публичный метод boolean isCollision(GameObject gameObject, Direction direction).
Этот метод должен возвращаться true, если при перемещении текущего
объекта в направлении direction на FIELD_CELL_SIZE произойдет
столкновение с объектом gameObject, переданным в качестве параметра.
Иначе &ndash; возвращать false. Столкновением считать совпадение координат x и y.



