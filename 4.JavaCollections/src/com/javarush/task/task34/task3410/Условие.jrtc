taskKey="com.javarush.task.task34.task3410.big14"\n\nSokoban (14)

Добавим немного интерактивности в нашу игру (перемещение игрока с помощью
клавиатуры). Начнем с обработки нажатия клавиш клавиатуры.
14.1. Добавь в класс Field вложенный класс KeyHandler унаследованный от KeyAdapter.
14.2. Переопредели у него метод keyPressed(). Если была нажата клавиша с кодом
VK_LEFT, то пошли eventListener-у событие move с параметром Direction.LEFT.
Аналогичным образом обработай нажатия клавиш с кодом VK_RIGHT, VK_UP и
VK_DOWN. Если пользователь нажал клавишу R с кодом VK_R, то вызови у слушателя событий метод restart().
14.3. В конструкторе класса Field:
14.3.1. Создай объект класса KeyHandler.
14.3.2. Добавь его слушателем с помощью метода addKeyListener().
14.3.3. Установи focusable в true (метод setFocusable()).


Требования:
1.	Добавь в класс Field вложенный public класс KeyHandler унаследованный от KeyAdapter.
2.	В классе KeyHandler правильно реализуй метод keyPressed().
3.	В конструкторе класса Field создай объект класса KeyHandler.
4.	В конструкторе класса Field добавь объект класса KeyHandler слушателем с помощью метода addKeyListener().
5.	В конструкторе класса Field установи focusable в true (метод setFocusable()).


Sokoban (14)

Наполним контроллер функционалом.
13.1. Добавь в конструктор класса Controller к тому, что уже есть еще и установку
слушателя событий у модели и представления. Слушателем должен быть сам контроллер.
13.2. Реализуй методы контроллера:
13.2.1. move(Direction direction) &ndash; должен вызывать move(Direction direction) у модели
и update() у представления. Метода move() у модели еще нет, добавь для него
заглушку, мы его реализуем позже.
13.2.2. restart() &ndash; должен перезапускать модель и обновлять представление.
13.2.3. startNextLevel() &ndash; должен запускать у модели новый уровень и обновлять
представление.
13.3. Добавь в представление метод completed(int level), который будет сообщать
пользователю, что уровень level пройден. Метод должен:
13.3.1. Обновлять представление.
13.3.2. Показывать диалоговое окно с информацией о том, что пользователь прошел
какой-то уровень. Подсказка: используй JOptionPane.showMessageDialog.
13.3.3. Просить контроллер запустить следующий уровень.
13.4. Реализуй в контроллере метод levelCompleted(int level), он должен вызвать
метод completed() у представления.



Sokoban (14)

Попробуем организовать взаимодействие представления и модели.
12.1. Добавь в класс View метод update(), он должен вызывать у игрового поля field
метод repaint(). Другими словами, метод update() будет обновлять представление
(перерисовывать поле).
12.2. Добавь в класс контроллера метод GameObjects getGameObjects(), он должен
запросить игровые объекты у модели и вернуть их. Добавь такой же метод и в класс
представления, он должен получать объекты у контроллера.
12.3. Правильно реализуй в классе Field метод paint(Graphics g). Он должен:
12.3.1. Залить все поле каким-то цветом, например, черным (вызови методы setColor и
fillRect).
12.3.2. Получить у представления все игровые объекты.
12.3.3. Отрисовать все игровые объекты.
12.4. Контроллер в своем конструкторе должен перезапускать модель.


Запусти программу и проверь, что все игровые объекты рисуются правильно.



Sokoban (14)

Начнем наполнять функционалом класс модели Model. Добавь в него:
11.1. Поле GameObjects gameObjects. Оно будет хранить наши игровые объекты.
11.2. Поле отвечающее за текущий уровень int currentLevel. Проинициализируй его значением 1.
11.3. Поле отвечающие за загрузчик уровней LevelLoader levelLoader.
Проинициализируй его с помощью файла levels.txt из папки res.
11.4. Метод GameObjects getGameObjects(), он должен возвращать все игровые объекты.
11.5. Метод restartLevel(int level), он должен получать новые игровые объекты для
указанного уровня у загрузчика уровня levelLoader и сохранять их в поле gameObjects.
11.6. Метод restart(), он должен перезапускать текущий уровень, вызывая restartLevel с нужным параметром.
11.7. Метод startNextLevel(), он должен увеличивать значение переменной
currentLevel, хранящей номер текущего уровня и выполнять перезапуск нового уровня.



Sokoban (14)

В игре будет несколько уровней, все уровни будут храниться в текстовом файле. Сейчас мы
напишем тестовую реализацию загрузчика уровней LevelLoader. Почему тестовую? Полный
функционал нам пока не нужен, он довольно сложный, оставим его на потом. А пока:
10.1. Создай класс LevelLoader в пакете model.
10.2. Добавь в класс конструктор, принимающий Path levels. Параметр levels &ndash; это
путь к тестовому файлу, содержащему описание уровней.
10.3. Добавь в класс LevelLoader метод GameObjects getLevel(int level). Пока не важно,
что будет возвращать этот метод. Пусть он всегда возвращает набор из: одного игрока,
одного дома, одного ящика и нескольких стен. Так будет проще отладить работу игры.
Координаты каждого объекта должны быть не нулевыми и кратными половине
FIELD_CELL_SIZE (центр каждого объекта должен быть в середине ячейки поля).



Sokoban (14)

В процессе работы игры, будут возникать различные события. Давай создадим интерфейс
слушателя событий EventListener. Его должен реализовывать каждый класс, который хочет
обрабатывать события. А классы, которые будут генерировать события, будут вызывать
методы этого интерфейса.
9.1. Добавь интерфейс EventListener в пакет controller.
9.2. Добавь в интерфейс void методы:
9.2.1. move(Direction direction) &ndash; передвинуть объект в определенном направлении.
9.2.2. restart() &ndash; начать заново текущий уровень.
9.2.3. startNextLevel() &ndash; начать следующий уровень.
9.2.4. levelCompleted(int level) &ndash; уровень с номером level завершён.
9.3. Добавь классу Controller интерфейс EventListener, напиши необходимые заглушки-
реализации интерфейса.
9.4. Добавь в классы Model и Field по полю EventListener eventListener.
9.5. Добавь в классы Model, View и Field по методу setEventListener(EventListener
eventListener). Этот метод в классе View должен вызвать аналогичный метод у объекта
field, а в классах Model и Field устанавливать значение внутренних полей eventListener.



