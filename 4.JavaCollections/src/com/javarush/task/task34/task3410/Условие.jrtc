taskKey="com.javarush.task.task34.task3410.big17"\n\nSokoban (17)

Ты супергерой! Ты сделал отличную игру, можешь немного отдохнуть и поиграть в нее.
Если она тебе когда-либо надоест, что практически невозможно, можешь заняться ее
улучшениями:
17.1. Использовать картинки для отображения объектов.
17.2. Сделать редактор уровней.
17.3. Добавить рейтинги, можешь даже сетевые :).
17.4. Переделать игру под мобильную платформу, опубликовать в магазине и
заработать кучу денег.

Так держать, ты стал еще на один шаг ближе к карьере программиста!


Требования:
1.	Еще одна большая задача пройдена!.


Sokoban (17)

Осталось дописать реализацию загрузчика уровней.
16.1. Открой файл levels.txt и внимательно изучи структуру файла. Символ &lsquo;X&rsquo; &ndash;
означает стену, &lsquo;*&rsquo; - ящик, &lsquo;.&rsquo; &ndash; дом, &lsquo;&amp;&rsquo; &ndash; ящик который стоит в доме, а &lsquo;@&rsquo; - игрока.
Всего в файле 60 уровней.
16.2. Реализуй метод GameObjects getLevel(int level). Он должен:
16.2.1. Вычитывать из файла данные уровня level. Уровни должны повторяться
циклически, если пользователь прошел все 60 уровней и попал на 61 уровень, то
ему нужно вернуть 1, вместо 62 уровня вернуть 2 и т.д.
16.2.2. Создать все игровые объекты, описанные в указанном уровне. Координаты
каждого игрового объекта должны быть рассчитаны согласно следующей логике:
16.2.2.1. Самый верхний левый объект (если такой есть) должен иметь
координаты x = x0 = FIELD_CELL_SIZE / 2 и y = y0 = FIELD_CELL_SIZE / 2.
16.2.2.2. Объект, который находится на одну позицию правее от него должен
иметь координаты x = x0 + FIELD_CELL_SIZE и y = y0.
16.2.2.3. Объект, который находится на одну позицию ниже от самого верхнего
левого должен иметь координаты x = x0 и y = y0 + FIELD_CELL_SIZE.
16.2.2.4. Аналогично должны рассчитываться координаты любого объекта на поле.
16.2.3. Создать новое хранилище объектов GameObjects и поместить в него все объекты.
16.2.4. Вернуть созданное хранилище.

Игра должна быть полностью рабочей. Проверь, если есть какие-то проблемы исправь их.



Sokoban (17)

Пришло время реализовать метод модели, отвечающий за движение move(), но для
начала реализуем вспомогательные методы. Добавь в класс модели методы:
15.1. boolean checkWallCollision(CollisionObject gameObject, Direction direction). Этот
метод проверяет столкновение со стеной. Он должен вернуть true, если при движении
объекта gameObject в направлении direction произойдет столкновение со стеной,
иначе false. Для определения столкновения используй метод isCollision() у игрового
объекта.
15.2. boolean checkBoxCollisionAndMoveIfAvailable(Direction direction). Этот метод проверяет
столкновение с ящиками. Метод должен:
15.2.1. Вернуть true, если игрок не может быть сдвинут в направлении direction (там
находится: или ящик, за которым стена; или ящик за которым еще один ящик).
15.2.2. Вернуть false, если игрок может быть сдвинут в направлении direction (там
находится: или свободная ячейка; или дом; или ящик, за которым свободная
ячейка или дом). При этом, если на пути есть ящик, который может быть сдвинут, то
необходимо переместить этот ящик на новые координаты. Обрати внимание, что
все объекты перемещаются на фиксированное значение FIELD_CELL_SIZE, не
зависящее от размеров объекта, которые используются для его отрисовки.
Подсказка: для определения столкновений используй методы isCollision() игровых
объектов и метод checkWallCollision() модели.
15.3. void checkCompletion(). Этот метод должен проверить пройден ли уровень (на
всех ли домах стоят ящики, их координаты должны совпадать). Если условие
выполнено, то проинформировать слушателя событий, что текущий уровень завершен.
15.4. void move(Direction direction). Метод должен:
15.4.1. Проверить столкновение со стеной (метод checkWallCollision()), если есть
столкновение &ndash; выйти из метода.
15.4.2. Проверить столкновение с ящиками (метод checkBoxCollisionAndMoveIfAvailable()), если есть
столкновение &ndash; выйти из метода.
15.4.3. Передвинуть игрока в направлении direction.
15.4.4. Проверить завершен ли уровень.

Запусти программу и проверь, что игрока можно перемещать, он может перемещать
ящики, стены преграждают движение, а при перемещении всех ящиков в дома выводится
сообщение о прохождении уровня.



Sokoban (17)

Добавим немного интерактивности в нашу игру (перемещение игрока с помощью
клавиатуры). Начнем с обработки нажатия клавиш клавиатуры.
14.1. Добавь в класс Field вложенный класс KeyHandler унаследованный от KeyAdapter.
14.2. Переопредели у него метод keyPressed(). Если была нажата клавиша с кодом
VK_LEFT, то пошли eventListener-у событие move с параметром Direction.LEFT.
Аналогичным образом обработай нажатия клавиш с кодом VK_RIGHT, VK_UP и
VK_DOWN. Если пользователь нажал клавишу R с кодом VK_R, то вызови у слушателя событий метод restart().
14.3. В конструкторе класса Field:
14.3.1. Создай объект класса KeyHandler.
14.3.2. Добавь его слушателем с помощью метода addKeyListener().
14.3.3. Установи focusable в true (метод setFocusable()).



Sokoban (17)

Наполним контроллер функционалом.
13.1. Добавь в конструктор класса Controller к тому, что уже есть еще и установку
слушателя событий у модели и представления. Слушателем должен быть сам контроллер.
13.2. Реализуй методы контроллера:
13.2.1. move(Direction direction) &ndash; должен вызывать move(Direction direction) у модели
и update() у представления. Метода move() у модели еще нет, добавь для него
заглушку, мы его реализуем позже.
13.2.2. restart() &ndash; должен перезапускать модель и обновлять представление.
13.2.3. startNextLevel() &ndash; должен запускать у модели новый уровень и обновлять
представление.
13.3. Добавь в представление метод completed(int level), который будет сообщать
пользователю, что уровень level пройден. Метод должен:
13.3.1. Обновлять представление.
13.3.2. Показывать диалоговое окно с информацией о том, что пользователь прошел
какой-то уровень. Подсказка: используй JOptionPane.showMessageDialog.
13.3.3. Просить контроллер запустить следующий уровень.
13.4. Реализуй в контроллере метод levelCompleted(int level), он должен вызвать
метод completed() у представления.



Sokoban (17)

Попробуем организовать взаимодействие представления и модели.
12.1. Добавь в класс View метод update(), он должен вызывать у игрового поля field
метод repaint(). Другими словами, метод update() будет обновлять представление
(перерисовывать поле).
12.2. Добавь в класс контроллера метод GameObjects getGameObjects(), он должен
запросить игровые объекты у модели и вернуть их. Добавь такой же метод и в класс
представления, он должен получать объекты у контроллера.
12.3. Правильно реализуй в классе Field метод paint(Graphics g). Он должен:
12.3.1. Залить все поле каким-то цветом, например, черным (вызови методы setColor и
fillRect).
12.3.2. Получить у представления все игровые объекты.
12.3.3. Отрисовать все игровые объекты.
12.4. Контроллер в своем конструкторе должен перезапускать модель.


Запусти программу и проверь, что все игровые объекты рисуются правильно.



