taskKey="com.javarush.task.task34.task3410.big10"\n\nSokoban (10)

В игре будет несколько уровней, все уровни будут храниться в текстовом файле. Сейчас мы
напишем тестовую реализацию загрузчика уровней LevelLoader. Почему тестовую? Полный
функционал нам пока не нужен, он довольно сложный, оставим его на потом. А пока:
10.1. Создай класс LevelLoader в пакете model.
10.2. Добавь в класс конструктор, принимающий Path levels. Параметр levels &ndash; это
путь к тестовому файлу, содержащему описание уровней.
10.3. Добавь в класс LevelLoader метод GameObjects getLevel(int level). Пока не важно,
что будет возвращать этот метод. Пусть он всегда возвращает набор из: одного игрока,
одного дома, одного ящика и нескольких стен. Так будет проще отладить работу игры.
Координаты каждого объекта должны быть не нулевыми и кратными половине
FIELD_CELL_SIZE (центр каждого объекта должен быть в середине ячейки поля).


Требования:
1.	Создай класс LevelLoader в пакете model.
2.	Добавь в класс конструктор, принимающий Path levels.
3.	Добавь в класс LevelLoader метод GameObjects getLevel(int level).
4.	Сделай тестовую реализацию метода getLevel согласно условию задания.


Sokoban (10)

В процессе работы игры, будут возникать различные события. Давай создадим интерфейс
слушателя событий EventListener. Его должен реализовывать каждый класс, который хочет
обрабатывать события. А классы, которые будут генерировать события, будут вызывать
методы этого интерфейса.
9.1. Добавь интерфейс EventListener в пакет controller.
9.2. Добавь в интерфейс void методы:
9.2.1. move(Direction direction) &ndash; передвинуть объект в определенном направлении.
9.2.2. restart() &ndash; начать заново текущий уровень.
9.2.3. startNextLevel() &ndash; начать следующий уровень.
9.2.4. levelCompleted(int level) &ndash; уровень с номером level завершён.
9.3. Добавь классу Controller интерфейс EventListener, напиши необходимые заглушки-
реализации интерфейса.
9.4. Добавь в классы Model и Field по полю EventListener eventListener.
9.5. Добавь в классы Model, View и Field по методу setEventListener(EventListener
eventListener). Этот метод в классе View должен вызвать аналогичный метод у объекта
field, а в классах Model и Field устанавливать значение внутренних полей eventListener.



Sokoban (10)

Ты создал полную коллекцию типов игровых объектов. Давай создадим класс, который будет хранить эти объекты.
8.1. Создай класс GameObjects в пакте model.
8.2. Добавь в него:
8.2.1. Поля Set&lt;Wall&gt; walls, Set&lt;Box&gt; boxes, Set&lt;Home&gt; homes и Player player.
8.2.2. Геттеры для этих полей.
8.2.3. Конструктор класса, принимающий Set&lt;Wall&gt; walls, Set &lt;Box&gt; boxes, Set&lt;Home&gt; homes,
Player player и инициализирующий поля класса.
8.2.4. Метод Set&lt;GameObject&gt; getAll(). Он должен возвращать множество, содержащее
все объекты, хранящиеся внутри класса.



Sokoban (10)

Давай сделаем класс стены Wall. Стена может сталкиваться с другими объектами, но не
может двигаться.
7.1. Добавь класс Wall в пакет model.
7.2. Унаследуй класс от подходящего родителя.
7.3. Реализуй конструктор с параметрами int x и int y.
7.4. Реализуй метод отрисовки.
Подсказка: стену можно нарисовать залитым квадратом коричневого цвета, но тебя
никто не ограничивает в выборе цвета, прояви свою творческую суть по полной.



Sokoban (10)

Пришло время создать класс Home. Этот класс будет отвечать за места на игровом поле
(дома) в которые нужно сдвинуть все ящики. Объекты этого типа не должны передвигаться
по полю или сталкиваться с другими игровыми объектами.
6.1. Добавь в пакет model класс Home.
6.2. Класс должен быть унаследован от максимально подходящего базового класса.
6.3. Добавь в созданный класс конструктор, принимающий int x и int y. Высота и ширина
дома должны быть равны 2.
6.4. Реализуй метод отрисовки дома. Подсказка: можешь использовать красный цвет и
прозрачный круг.

Как и с предыдущими игровыми объектами, можешь проверить метод отрисовки в методе
paint() класса Field.



Sokoban (10)

Игровые объекты &ldquo;Ящик&rdquo; и &ldquo;Игрок&rdquo; с одной стороны являются объектами, которые могут
сталкиваться, а с другой они могут перемещаться по полю.
5.1. Создай класс игрока Player и класс ящика Box в пакете model. Каждый из них
унаследуй от максимально подходящего класса.
5.2. Созданные классы должны поддерживать интерфейс, отвечающий за движение
объектов.
5.3. Добавь в созданные классы конструкторы, принимающие int x и int y.
5.4. В каждом из классов, реализуй метод, отвечающий за движение. Он должен смещать
координаты объектов (x и y) на переданные значения.
5.5. В каждом из них, реализуй метод, отвечающий за отрисовку. Этот метод должен:
устанавливать какой-то цвет и рисовать какие-то примитивные фигуры. Проследи,
чтобы центр фигуры имел координаты x и y, а высота и ширина соответствовали
значениям полей height и width.
Подсказка: игрока можешь нарисовать желтым залитым кругом, а ящик &ndash; оранжевым
квадратом с прорисованными диагоналями. Это пример, ты можешь сам выбрать цвет
и вид каждого объекта, ты ограничен только методами доступными для Graphics и
своей фантазией.

Для того чтобы проверить как рисуется твой ящик или игрок, ты можешь создать
объект типа Box или Player в методе paint() класса Field и вызвать у объекта метод
draw(). Сделай это исключительно для проверки методов draw(), в дальнейшем метод
paint() мы реализуем иначе.



