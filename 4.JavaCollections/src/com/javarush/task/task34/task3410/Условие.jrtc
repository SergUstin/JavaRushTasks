taskKey="com.javarush.task.task34.task3410.big15"\n\nSokoban (15)

Пришло время реализовать метод модели, отвечающий за движение move(), но для
начала реализуем вспомогательные методы. Добавь в класс модели методы:
15.1. boolean checkWallCollision(CollisionObject gameObject, Direction direction). Этот
метод проверяет столкновение со стеной. Он должен вернуть true, если при движении
объекта gameObject в направлении direction произойдет столкновение со стеной,
иначе false. Для определения столкновения используй метод isCollision() у игрового
объекта.
15.2. boolean checkBoxCollisionAndMoveIfAvailable(Direction direction). Этот метод проверяет
столкновение с ящиками. Метод должен:
15.2.1. Вернуть true, если игрок не может быть сдвинут в направлении direction (там
находится: или ящик, за которым стена; или ящик за которым еще один ящик).
15.2.2. Вернуть false, если игрок может быть сдвинут в направлении direction (там
находится: или свободная ячейка; или дом; или ящик, за которым свободная
ячейка или дом). При этом, если на пути есть ящик, который может быть сдвинут, то
необходимо переместить этот ящик на новые координаты. Обрати внимание, что
все объекты перемещаются на фиксированное значение FIELD_CELL_SIZE, не
зависящее от размеров объекта, которые используются для его отрисовки.
Подсказка: для определения столкновений используй методы isCollision() игровых
объектов и метод checkWallCollision() модели.
15.3. void checkCompletion(). Этот метод должен проверить пройден ли уровень (на
всех ли домах стоят ящики, их координаты должны совпадать). Если условие
выполнено, то проинформировать слушателя событий, что текущий уровень завершен.
15.4. void move(Direction direction). Метод должен:
15.4.1. Проверить столкновение со стеной (метод checkWallCollision()), если есть
столкновение &ndash; выйти из метода.
15.4.2. Проверить столкновение с ящиками (метод checkBoxCollisionAndMoveIfAvailable()), если есть
столкновение &ndash; выйти из метода.
15.4.3. Передвинуть игрока в направлении direction.
15.4.4. Проверить завершен ли уровень.

Запусти программу и проверь, что игрока можно перемещать, он может перемещать
ящики, стены преграждают движение, а при перемещении всех ящиков в дома выводится
сообщение о прохождении уровня.


Требования:
1.	Реализуй в классе модели метод boolean checkWallCollision(CollisionObject gameObject, Direction direction).
2.	Реализуй в классе модели метод boolean checkBoxCollisionAndMoveIfAvailable(Direction direction).
3.	Реализуй в классе модели метод void checkCompletion().
4.	Реализуй в классе модели метод void move(Direction direction).


Sokoban (15)

Добавим немного интерактивности в нашу игру (перемещение игрока с помощью
клавиатуры). Начнем с обработки нажатия клавиш клавиатуры.
14.1. Добавь в класс Field вложенный класс KeyHandler унаследованный от KeyAdapter.
14.2. Переопредели у него метод keyPressed(). Если была нажата клавиша с кодом
VK_LEFT, то пошли eventListener-у событие move с параметром Direction.LEFT.
Аналогичным образом обработай нажатия клавиш с кодом VK_RIGHT, VK_UP и
VK_DOWN. Если пользователь нажал клавишу R с кодом VK_R, то вызови у слушателя событий метод restart().
14.3. В конструкторе класса Field:
14.3.1. Создай объект класса KeyHandler.
14.3.2. Добавь его слушателем с помощью метода addKeyListener().
14.3.3. Установи focusable в true (метод setFocusable()).



Sokoban (15)

Наполним контроллер функционалом.
13.1. Добавь в конструктор класса Controller к тому, что уже есть еще и установку
слушателя событий у модели и представления. Слушателем должен быть сам контроллер.
13.2. Реализуй методы контроллера:
13.2.1. move(Direction direction) &ndash; должен вызывать move(Direction direction) у модели
и update() у представления. Метода move() у модели еще нет, добавь для него
заглушку, мы его реализуем позже.
13.2.2. restart() &ndash; должен перезапускать модель и обновлять представление.
13.2.3. startNextLevel() &ndash; должен запускать у модели новый уровень и обновлять
представление.
13.3. Добавь в представление метод completed(int level), который будет сообщать
пользователю, что уровень level пройден. Метод должен:
13.3.1. Обновлять представление.
13.3.2. Показывать диалоговое окно с информацией о том, что пользователь прошел
какой-то уровень. Подсказка: используй JOptionPane.showMessageDialog.
13.3.3. Просить контроллер запустить следующий уровень.
13.4. Реализуй в контроллере метод levelCompleted(int level), он должен вызвать
метод completed() у представления.



Sokoban (15)

Попробуем организовать взаимодействие представления и модели.
12.1. Добавь в класс View метод update(), он должен вызывать у игрового поля field
метод repaint(). Другими словами, метод update() будет обновлять представление
(перерисовывать поле).
12.2. Добавь в класс контроллера метод GameObjects getGameObjects(), он должен
запросить игровые объекты у модели и вернуть их. Добавь такой же метод и в класс
представления, он должен получать объекты у контроллера.
12.3. Правильно реализуй в классе Field метод paint(Graphics g). Он должен:
12.3.1. Залить все поле каким-то цветом, например, черным (вызови методы setColor и
fillRect).
12.3.2. Получить у представления все игровые объекты.
12.3.3. Отрисовать все игровые объекты.
12.4. Контроллер в своем конструкторе должен перезапускать модель.


Запусти программу и проверь, что все игровые объекты рисуются правильно.



Sokoban (15)

Начнем наполнять функционалом класс модели Model. Добавь в него:
11.1. Поле GameObjects gameObjects. Оно будет хранить наши игровые объекты.
11.2. Поле отвечающее за текущий уровень int currentLevel. Проинициализируй его значением 1.
11.3. Поле отвечающие за загрузчик уровней LevelLoader levelLoader.
Проинициализируй его с помощью файла levels.txt из папки res.
11.4. Метод GameObjects getGameObjects(), он должен возвращать все игровые объекты.
11.5. Метод restartLevel(int level), он должен получать новые игровые объекты для
указанного уровня у загрузчика уровня levelLoader и сохранять их в поле gameObjects.
11.6. Метод restart(), он должен перезапускать текущий уровень, вызывая restartLevel с нужным параметром.
11.7. Метод startNextLevel(), он должен увеличивать значение переменной
currentLevel, хранящей номер текущего уровня и выполнять перезапуск нового уровня.



Sokoban (15)

В игре будет несколько уровней, все уровни будут храниться в текстовом файле. Сейчас мы
напишем тестовую реализацию загрузчика уровней LevelLoader. Почему тестовую? Полный
функционал нам пока не нужен, он довольно сложный, оставим его на потом. А пока:
10.1. Создай класс LevelLoader в пакете model.
10.2. Добавь в класс конструктор, принимающий Path levels. Параметр levels &ndash; это
путь к тестовому файлу, содержащему описание уровней.
10.3. Добавь в класс LevelLoader метод GameObjects getLevel(int level). Пока не важно,
что будет возвращать этот метод. Пусть он всегда возвращает набор из: одного игрока,
одного дома, одного ящика и нескольких стен. Так будет проще отладить работу игры.
Координаты каждого объекта должны быть не нулевыми и кратными половине
FIELD_CELL_SIZE (центр каждого объекта должен быть в середине ячейки поля).



