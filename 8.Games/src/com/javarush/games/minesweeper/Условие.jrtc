taskKey="com.javarush.games.minesweeper.part11"\n\nИгра сапер (11/16)

Практически в любой игре игрок либо выигрывает, либо проигрывает. Давай для начала реализуем проигрыш.
Для этого нам пригодится метод gameOver(), который будет останавливать игру и сообщать игроку о проигрыше.
Для вывода сообщения игроку в движке предусмотрен метод showMessageDialog().
Чтобы контролировать остановку игры, введем специальную переменную-флаг isGameStopped. При каких
обстоятельствах происходит проигрыш? Правильно: при открытии &quot;заминированной&quot; ячейки. Если такое
событие наступило, нужно ячейку с миной перекрасить в красный цвет (Color.RED) и вызвать метод gameOver().
Не забудь учесть остановку игры в методе markTile(int, int). Запусти игру и проверь, что все реализованное
тобой работает.


Требования:
1.	В классе MinesweeperGame должно существовать приватное поле isGameStopped типа boolean.
2.	В методе createGame() должно устанавливаться значение переменной isGameStopped в false.
3.	В классе MinesweeperGame должен существовать приватный метод void gameOver().
4.	Метод gameOver() должен устанавливать значение переменной isGameStopped в true.
5.	Метод gameOver() должен вызывать метод showMessageDialog(Color, String, Color, int).
6.	В методе openTile(int, int), если объект является миной, должна отрисовываться мина на красном фоне (используй метод setCellValueEx(int, int, Color, String)) и вызываться метод gameOver().
7.	Метод markTile(int, int) не должен ничего делать, если игра уже остановлена (isGameStopped == true).


Игра сапер (11/16)

Теперь давай займемся реализацией метода, который отвечает за маркировку ячейки флажком. Метод назовем markTile.
Он должен:
- отмечать ячейку на игровом поле флагом или снимать флаг;
- следить за количеством флагов;
- заниматься отрисовкой и стиранием флагов на игровом поле;
- менять цвет ячейки поля, если в ней устанавливается флаг и возвращать цвет обратно, если флаг снимается.
Поставить или снять флаг в игре можно с помощью клика правой кнопки мыши. Поэтому в классе MinesweeperGame
нужно переопределить метод onMouseRightClick(int, int) класса Game и в нем вызвать метод markTile(int x, int y).
Проверь, что все работает &mdash; запусти игру.



Игра сапер (11/16)

Согласно правилам игры, при открытии ячейки, количество &quot;заминированных&quot; соседей которой равно нулю,
открывается некоторая &quot;не заминированная&quot; область до ячеек с &quot;заминированными&quot;
соседями. Давай это реализуем... Предлагаю использовать рекурсию. Ее применяют тогда,
когда алгоритм решения задачи совпадает с алгоритмом решения подзадачи (части). У нас как раз такой случай.
При открытии ячейки с нулевым количеством &quot;заминированных&quot; соседей нам нужно сделать полный перебор всех
закрытых соседних ячеек, вызвать у них метод openTile(int, int) и повторить процесс.
Также в методе openTile(int, int) реализуем показ в ячейке количества &quot;заминированных&quot; соседей.
Запусти игру, чтобы проверить корректность реализации.
Подсказка: если получил java.lang.StackOverflowError, значит ты поздно устанавливаешь флаг, что ячейка уже открыта.



Игра сапер (11/16)

Согласно правилам игры, в помощь игроку даются флаги. Они нужны, чтобы
помечать потенциально &quot;заминированные&quot; ячейки. Поэтому количество флагов countFlags должно равняться
количеству мин countMinesOnField. Флаг нужно как-то показывать на игровом поле. Для этого создадим
переменную-константу, которая будет хранить его символ. У каждой ячейки модели должно быть состояние
isFlag, которое покажет нам, помечена ли ячейка флагом или нет.



Игра сапер (11/16)

На данном этапе мы займемся открытием ячеек. Давай создадим метод, отвечающий за это,
и переменную, которая будет хранить состояние ячейки (открыта или нет). При открытии ячейки метод будет:
- рисовать в ячейке мину, если там мина;
- отображать количество мин-соседей, если в ячейке нет мины;
- отмечать ячейку модели открытой;
- менять цвет ячейки.
Символ мины для удобства предлагаем вынести в отдельную переменную-константу. Когда ячейка должна открываться? Правильно,
при клике по ней левой кнопкой мыши. Для обработки такого нажатия существует специальный метод движка &mdash; onMouseLeftClick(int, int).
Давай переопределим его в нашем классе. Он будет вызывать метод открытия ячейки.
Ну и, конечно же, запусти программу и насладись результатом работы.



Игра сапер (11/16)

Теперь давай займемся подсчетом мин в соседних ячейках. Для этого каждой ячейке матрицы добавим параметр
(поле класса), который отвечает за количество &quot;заминированных&quot; соседей. Сначала найдем всех соседей,
а потом посчитаем, сколько из них &quot;заминированы&quot;.
Для получения списка соседей у тебя появился метод getNeighbors(), который принимает один параметр типа GameObject (ячейку).
Осталось в отдельном методе посчитать количество &quot;заминированных&quot; соседей для каждой ячейки из gameField
и внесем это значение в соответствующее поле ячейки матрицы.
Хотя визуально твоя работа не видна (ты же запустил программу, чтобы посмотреть что получилось?), она очень важна для будущих шагов.



