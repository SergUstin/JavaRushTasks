taskKey="com.javarush.games.minesweeper.part10"\n\nИгра сапер (10/16)

Теперь давай займемся реализацией метода, который отвечает за маркировку ячейки флажком. Метод назовем markTile.
Он должен:
- отмечать ячейку на игровом поле флагом или снимать флаг;
- следить за количеством флагов;
- заниматься отрисовкой и стиранием флагов на игровом поле;
- менять цвет ячейки поля, если в ней устанавливается флаг и возвращать цвет обратно, если флаг снимается.
Поставить или снять флаг в игре можно с помощью клика правой кнопки мыши. Поэтому в классе MinesweeperGame
нужно переопределить метод onMouseRightClick(int, int) класса Game и в нем вызвать метод markTile(int x, int y).
Проверь, что все работает &mdash; запусти игру.


Требования:
1.	В классе MinesweeperGame должен существовать приватный метод void markTile(int, int).
2.	Метод markTile(int x, int y) не должен ничего делать, если элемент уже открыт (isOpen == true).
3.	Метод markTile(int, int) не должен ничего делать, если количество неиспользованных флагов countFlags равно нулю, и текущий элемент &mdash; не флаг (isFlag = false).
4.	Метод markTile(int, int) должен устанавливать значение поля isFlag в true, уменьшать количество неиспользованных флагов на единицу, отрисовывать на поле знак FLAG, если текущий элемент &mdash; не флаг (используй метод setCellValue(int, int, String)) и менять фон ячейки на поле, используя метод setCellColor(int, int, Color). Например, в Color.YELLOW.
5.	Метод markTile(int, int) должен устанавливать значение поля isFlag в false, увеличивать количество неиспользованных флагов на единицу, отрисовывать на поле пустую ячейку, если текущий элемент &mdash; флаг (используй метод setCellValue(int, int, String)) и возвращать исходный цвет ячейки (используй метод setCellColor(int, int, Color)).
6.	В классе MinesweeperGame должен быть переопределен метод onMouseRightClick(int, int) родительского класса Game.
7.	Метод onMouseRightClick(int, int) должен вызывать метод markTile(int, int).


Игра сапер (10/16)

Согласно правилам игры, при открытии ячейки, количество &quot;заминированных&quot; соседей которой равно нулю,
открывается некоторая &quot;не заминированная&quot; область до ячеек с &quot;заминированными&quot;
соседями. Давай это реализуем... Предлагаю использовать рекурсию. Ее применяют тогда,
когда алгоритм решения задачи совпадает с алгоритмом решения подзадачи (части). У нас как раз такой случай.
При открытии ячейки с нулевым количеством &quot;заминированных&quot; соседей нам нужно сделать полный перебор всех
закрытых соседних ячеек, вызвать у них метод openTile(int, int) и повторить процесс.
Также в методе openTile(int, int) реализуем показ в ячейке количества &quot;заминированных&quot; соседей.
Запусти игру, чтобы проверить корректность реализации.
Подсказка: если получил java.lang.StackOverflowError, значит ты поздно устанавливаешь флаг, что ячейка уже открыта.



Игра сапер (10/16)

Согласно правилам игры, в помощь игроку даются флаги. Они нужны, чтобы
помечать потенциально &quot;заминированные&quot; ячейки. Поэтому количество флагов countFlags должно равняться
количеству мин countMinesOnField. Флаг нужно как-то показывать на игровом поле. Для этого создадим
переменную-константу, которая будет хранить его символ. У каждой ячейки модели должно быть состояние
isFlag, которое покажет нам, помечена ли ячейка флагом или нет.



Игра сапер (10/16)

На данном этапе мы займемся открытием ячеек. Давай создадим метод, отвечающий за это,
и переменную, которая будет хранить состояние ячейки (открыта или нет). При открытии ячейки метод будет:
- рисовать в ячейке мину, если там мина;
- отображать количество мин-соседей, если в ячейке нет мины;
- отмечать ячейку модели открытой;
- менять цвет ячейки.
Символ мины для удобства предлагаем вынести в отдельную переменную-константу. Когда ячейка должна открываться? Правильно,
при клике по ней левой кнопкой мыши. Для обработки такого нажатия существует специальный метод движка &mdash; onMouseLeftClick(int, int).
Давай переопределим его в нашем классе. Он будет вызывать метод открытия ячейки.
Ну и, конечно же, запусти программу и насладись результатом работы.



Игра сапер (10/16)

Теперь давай займемся подсчетом мин в соседних ячейках. Для этого каждой ячейке матрицы добавим параметр
(поле класса), который отвечает за количество &quot;заминированных&quot; соседей. Сначала найдем всех соседей,
а потом посчитаем, сколько из них &quot;заминированы&quot;.
Для получения списка соседей у тебя появился метод getNeighbors(), который принимает один параметр типа GameObject (ячейку).
Осталось в отдельном методе посчитать количество &quot;заминированных&quot; соседей для каждой ячейки из gameField
и внесем это значение в соответствующее поле ячейки матрицы.
Хотя визуально твоя работа не видна (ты же запустил программу, чтобы посмотреть что получилось?), она очень важна для будущих шагов.



Игра сапер (10/16)

Игра &quot;Сапер&quot; не зря так называется. Игроку нужно будет иметь дело с минами, хотя лучше с ними дела не иметь :)
Давай введем в игру эти самые мины. Для этого в класс GameObject внесем изменения, которые учитывают,
что ячейка может быть миной &mdash; это флаг isMine.
Новый конструктор создавать не нужно: достаточно отредактировать существующий.
Кроме того, при создании ячеек матрицы добавь генерацию мин с вероятностью 10%. Самый простой способ это
сделать &mdash; использовать метод getRandomNumber(int n) класса Game, который возвращает случайное число от
0 до n-1 включительно. Следовательно, вероятность генерации определенного числа равна 1/n.
Также не забудь посчитать количество сгенерированных мин в классе MinesweeperGame.
Если все сделал, запусти программу и проверь, что ничего не поломалось :)



