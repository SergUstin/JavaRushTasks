taskKey="com.javarush.games.snake.part16"\n\nИгра змейка (16/20)

Игра должна останавливаться и в случае победы. Победа наступает, когда змейка увеличивается до определённого размера. Для хранения этого размера
в классе SnakeGame создай константу GOAL и инициализируй её значением 28. Для определения текущего размера змейки в классе Snake, создай
метод getLength() и реализуй его. По аналогии с методом gameOver(), создай и реализуй метод win(). Только вместо надписи &quot;GAME OVER&quot; он должен
выводить &quot;YOU WIN&quot;. Проверка победы также производится в конце каждого хода.


Требования:
1.	В классе SnakeGame должно существовать приватное статическое final int поле GOAL, инициализированное при объявлении значением 28.
2.	В классе Snake должен существовать публичный метод int getLength(), который возвращает количество сегментов змеи в списке snakeParts.
3.	В классе SnakeGame должен существовать приватный метод void win().
4.	В методе win() должен вызываться метод stopTurnTimer().
5.	В методе win() полю isGameStopped должно устанавливаться значение true.
6.	В методе win() должен вызываться метод showMessageDialog(Color, String, Color, int).
7.	В методе onTurn(int) должен вызываться метод win() перед методом drawScene(), если значение, возвращенное методом getLength(), больше чем GOAL.


Игра змейка (16/20)

Для хранения состояния игры нам понадобится переменная isGameStopped в классе SnakeGame. Проинициализируй
её в методе createGame(). Когда игра проиграна, её нужно остановить и вывести сообщение об этом игроку.
Для этого создай метод gameOver() и добавь в него команды, которые выполняются при остановке игры (проигрыше):
- вызов метода stopTurnTimer();
- присвоение флагу isGameStopped значения true;
- вывод сообщения &quot;GAME OVER&quot;.
Проверку состояния флага isGameStopped нужно проводить в конце каждого хода, и если игра остановлена, вызывать метод gameOver().



Игра змейка (16/20)

Сейчас змейка может ходить сквозь свое тело, а это не по правилам. Чтобы это исправить, нужно проверять новосозданную голову змейки на совпадение
со всеми остальными элементами её тела. Для этого в классе Snake создай метод checkCollision(GameObject). Метод checkCollision(GameObject) должен
возвращать true, если координаты переданного объекта совпадают с координатами одного из элементов тела змейки. Также в методе move(Apple) добавь
проверку на столкновения новой головы и тела. Если было столкновение, установи переменной isAlive значение false.



Игра змейка (16/20)

До этого мы устанавливали координаты яблока вручную. Необходимо создать метод для генерации новых яблок. Назовем его createNewApple().
Метод должен генерировать случайные координаты ячейки в пределах игрового поля, на которой будет появляться яблоко. Ссылку на новосозданное
яблоко присвой полю apple. Также в конце каждого хода нужно проверить, &quot;живое&quot; ли текущее яблоко, если нет &mdash; создать новое.
Для генерирования случайных чисел вызывай метод родительского класса getRandomNumber(int).



Игра змейка (16/20)

У нас уже есть змейка, которая умеет двигаться, и яблоко. Теперь реализуем их взаимодействие. Для начала добавь переменную яблока в
класс SnakeGame, и в момент создания игры инициализируй ее координатами (5, 5). Также прорисуй яблоко.

Перепиши метод move() класса Snake. Теперь в качестве аргумента он должен принимать яблоко, и если окажется, что змейка &quot;съела&quot; яблоко, состояние
яблока должно устанавливаться в &quot;неживое&quot;, а размер змейки &mdash; увеличиваться на 1 элемент.



Игра змейка (16/20)

Добавим возможность управления нашей змейкой. Для считывания клавиш переопредели метод onKeyPress(Key) родительского класса Game. В зависимости от
нажатой клавиши, установи соответствующее направление движения змейке. Учти, что змейка не может мгновенно развернуться на 180 градусов.



