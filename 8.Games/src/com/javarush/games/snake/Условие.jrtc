taskKey="com.javarush.games.snake.part18"\n\nИгра змейка (18/20)

Давай поправим управление. Значения поля direction могут меняться только на валидные в данный момент: LEFT, RIGHT, UP, DOWN.


Требования:
1.	Метод setDirection(Direction) класса Snake не должен ничего делать, если значение поля direction равно LEFT, и сегменты змейки из snakeParts с индексами 0 и 1 имеют одинаковое значение координаты x.
2.	Метод setDirection(Direction) класса Snake не должен ничего делать, если значение поля direction равно RIGHT, и сегменты змейки из snakeParts с индексами 0 и 1 имеют одинаковое значение координаты x.
3.	Метод setDirection(Direction) класса Snake не должен ничего делать, если значение поля direction равно UP, и сегменты змейки из snakeParts с индексами 0 и 1 имеют одинаковое значение координаты y.
4.	Метод setDirection(Direction) класса Snake не должен ничего делать, если значение поля direction равно DOWN, и сегменты змейки из snakeParts с индексами 0 и 1 имеют одинаковое значение координаты y.


Игра змейка (18/20)

На данном этапе у нас есть один баг &mdash; яблоко может сгенерироваться на теле змейки. Для устранения бага, воспользуемся созданным
методом checkCollision(GameObject). Метод createNewApple() должен создавать новое яблоко (с новыми координатами) в цикле до тех пор,
пока результат вызова метода checkCollision(GameObject) не будет false.

Также давай реализуем рестарт игры нажатием клавиши SPACE (пробел). Игра запускается заново только если она остановлена.



Игра змейка (18/20)

Игра должна останавливаться и в случае победы. Победа наступает, когда змейка увеличивается до определённого размера. Для хранения этого размера
в классе SnakeGame создай константу GOAL и инициализируй её значением 28. Для определения текущего размера змейки в классе Snake, создай
метод getLength() и реализуй его. По аналогии с методом gameOver(), создай и реализуй метод win(). Только вместо надписи &quot;GAME OVER&quot; он должен
выводить &quot;YOU WIN&quot;. Проверка победы также производится в конце каждого хода.



Игра змейка (18/20)

Для хранения состояния игры нам понадобится переменная isGameStopped в классе SnakeGame. Проинициализируй
её в методе createGame(). Когда игра проиграна, её нужно остановить и вывести сообщение об этом игроку.
Для этого создай метод gameOver() и добавь в него команды, которые выполняются при остановке игры (проигрыше):
- вызов метода stopTurnTimer();
- присвоение флагу isGameStopped значения true;
- вывод сообщения &quot;GAME OVER&quot;.
Проверку состояния флага isGameStopped нужно проводить в конце каждого хода, и если игра остановлена, вызывать метод gameOver().



Игра змейка (18/20)

Сейчас змейка может ходить сквозь свое тело, а это не по правилам. Чтобы это исправить, нужно проверять новосозданную голову змейки на совпадение
со всеми остальными элементами её тела. Для этого в классе Snake создай метод checkCollision(GameObject). Метод checkCollision(GameObject) должен
возвращать true, если координаты переданного объекта совпадают с координатами одного из элементов тела змейки. Также в методе move(Apple) добавь
проверку на столкновения новой головы и тела. Если было столкновение, установи переменной isAlive значение false.



Игра змейка (18/20)

До этого мы устанавливали координаты яблока вручную. Необходимо создать метод для генерации новых яблок. Назовем его createNewApple().
Метод должен генерировать случайные координаты ячейки в пределах игрового поля, на которой будет появляться яблоко. Ссылку на новосозданное
яблоко присвой полю apple. Также в конце каждого хода нужно проверить, &quot;живое&quot; ли текущее яблоко, если нет &mdash; создать новое.
Для генерирования случайных чисел вызывай метод родительского класса getRandomNumber(int).



