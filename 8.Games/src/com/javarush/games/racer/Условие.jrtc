taskKey="com.javarush.games.racer.part22"\n\nИгра Racer (22/28)

Приступим к созданию финишной линии. Матрица для нее уже есть в ShapeMatrix.
Финишная линия появится на трассе в конце игры.
На самом деле объект финишной линии создается в начале игры, но находится выше игрового поля, поэтому невидим.
Как только флаг, ответственный за отображение FinishLine, получит значение true, финишная линия начнет движение вниз и появится на игровом поле.


Требования:
1.	В отдельном файле должен существовать публичный класс FinishLine.
2.	Класс FinishLine должен быть наследником класса GameObject.
3.	В классе FinishLine должен существовать публичный конструктор без параметров, который вызывает конструктор базового класса с параметрами: RacerGame.ROADSIDE_WIDTH, -1 * ShapeMatrix.FINISH_LINE.length, ShapeMatrix.FINISH_LINE.
4.	В классе FinishLine должно существовать приватное поле isVisible типа boolean, проинициализированное при объявлении значением false.
5.	В классе FinishLine должен существовать публичный метод void show().
6.	Метод show() должен устанавливать значение полю isVisible, равное true.
7.	В классе FinishLine должен существовать публичный метод void move(int boost).
8.	Метод move(int) не должен ничего делать, если финишная линия не видна (isVisible равно false).
9.	Метод move(int boost) должен увеличивать координату y финишной линии на значение boost.


Игра Racer (22/28)

Давай немного усложним игру.
Добавим машину с &quot;пьяным&quot; водителем.
Для ее представления на игровом поле в пакет road был добавлен новый класс MovingCar. Используй его для создания таких машин.
В отличие от обычных машин, &quot;пьяный&quot; водитель будет двигаться и по горизонтали.
Чтобы он не пересекался с другими машинами, в методе move() класса MovingCar, происходит проверка таких пересечений.
Для этого в метод move(int boost), кроме скорости, нужно еще передавать список всех объектов-препятствий.

Еще одна тонкость заключается в том, что MovingCar &mdash; наследник класса RoadObject, и переопределяет его метод move,
поэтому необходимо добавить второй аргумент и методу move в родительском классе.

При большом количестве &quot;пьяных&quot; водителей на трассе игра станет слишком сложной, поэтому позаботься о том,
чтобы на трассе одновременно была только одна такая машина.
Для проверки этого реализуй метод isMovingCarExists() по аналогии с методом isThornExists().

За генерацию MovingCar будет отвечать отдельный метод void generateMovingCar(Game).
Его реализация аналогична реализации метода generateThorn(Game).



Игра Racer (22/28)

Сейчас встречных машин слишком много.
Чтобы игру можно было пройти, промежутки между препятствиями должны быть достаточно большими.
С другой стороны, если они будут слишком большие, игра станет очень простой и не такой интересной.
Оптимальным расстоянием будет 12: оно соответствует габаритам машины игрока с небольшим запасом.
Это значение будем хранить в константе PLAYER_CAR_DISTANCE.

Реализуй метод boolean isRoadSpaceFree(RoadObject object), который будет проверять,
есть ли достаточно свободного места на дороге для размещения новой машины.
В этом тебе поможет метод isCollisionWithDistance(GameObject, int). Этот метод возвращает false,
если расстояние между объектами по горизонтали и вертикали больше переданной дистанции.
Если на дороге есть свободное место, добавляй новую машину в items.



Игра Racer (22/28)

Кроме шипов, на трассе неплохо бы смотрелись машины разных типов.
Для представления машин на игровом поле создай в пакете road общий для всех типов машин класс Car и унаследуй его от RoadObject.
Все машины будут двигаться со скоростью 1.

Так как метод createRoadObject(RoadObjectType, int, int) класса RoadManager отвечает за создание всех дорожных объектов,
вместо null он должен возвращать новый объект типа Car.
Для генерации новых машин создай метод generateRegularCar(Game game) в классе RoadManager.
Чтобы трасса не была слишком загружена, новая машина должна создаваться с вероятностью 30%.
Тип машины должен быть случайно выбран из первых четырех элементов RoadObjectType.
Не забудь каждую созданную машину добавить в список items.



Игра Racer (22/28)

После завершения игры должна быть возможность начать заново. Реализуй перезапуск игры по нажатию клавиши SPACE.

Чтобы игрок мог быстрее преодолеть трассу, его машина должна иметь возможность увеличивать скорость.
Реализуй увеличение скорости в 2 раза по нажатию клавиши UP, а при отпускании этой клавиши &mdash; возвращение к начальной скорости.



Игра Racer (22/28)

Игра должна останавливаться в двух случаях: когда игрок выиграл или проиграл. Пока реализуем остановку только для проигрышей.
Для хранения текущего состояния игры создадим поле boolean isGameStopped, начальное состояние которого должно быть false.
Когда игрок сталкивается с препятствием &mdash; он проиграл, а значит игра должна остановиться, а на экран &mdash; вывестись сообщение, например, GAME OVER.
Все действия, которые осуществляются при проигрыше, удобно вынести в отдельный метод gameOver().
В методе onTurn(int) нужно проверять пересечение игрока с препятствиями (метод checkCrush(PlayerCar)).



