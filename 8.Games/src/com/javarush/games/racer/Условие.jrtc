taskKey="com.javarush.games.racer.part11"\n\nИгра Racer (11/28)

На пути игрока будут различные препятствия: другие машины, едущие навстречу, и шипы, неподвижные относительно трассы.
Эти препятствия будут наследоваться от класса RoadObject. Типы всех возможных препятствий перечислены в enum RoadObjectType.
Эти классы появились у тебя в пакете road. А класс ShapeMatrix пополнился новыми матрицами для отображения препятствий.
Просмотри класс RoadObject и его методы.

На этом этапе займемся шипами. Создай класс Thorn (шипы) и унаследуй его от RoadObject.
Для создания объектов-препятствий в классе RoadManager создай метод private RoadObject createRoadObject(RoadObjectType type, int x, int y),
который в зависимости от полученных параметров будет создавать и возвращать новое препятствие.
Пока у нас есть единственный тип препятствий &mdash; Thorn, поэтому если метод createRoadObject получит в качестве аргумента какой-то другой тип, он должен вернуть null.
Зная тип игрового объекта, не нужно передавать ему матрицу изображения в конструкторе, поэтому в классе GameObject понадобится еще один конструктор с двумя параметрами:
int x, int y, который устанавливает соответствующие значения полям x, y.


Требования:
1.	В классе GameObject должен существовать публичный конструктор с двумя параметрами: int x, int y, который устанавливает соответствующие значения полям x, y.
2.	В пакете road в отдельном файле должен существовать публичный класс Thorn.
3.	Класс Thorn должен быть наследником класса RoadObject.
4.	В классе Thorn должен существовать публичный конструктор с двумя параметрами: int x, int y, который вызывает конструктор базового класса с параметрами: RoadObjectType.THORN, x, y.
5.	В конструкторе класса Thorn поле speed (поле суперкласса) должно инициализироваться значением 0.
6.	В классе RoadManager должен существовать приватный метод RoadObject createRoadObject(RoadObjectType type, int x, int y).
7.	Метод createRoadObject(RoadObjectType, int, int) должен вернуть новый объект типа Thorn, если type равен RoadObjectType.THORN.
8.	Метод createRoadObject(RoadObjectType, int, int) должен вернуть null, если type не равен RoadObjectType.THORN.
9.	В методе createRoadObject(RoadObjectType, int, int) конструктор класса Thorn должен быть вызван с параметрами x, y (соответствующие параметры метода).


Игра Racer (11/28)

На данный момент поведение машины не совсем соответствует ожидаемому:
- машина не перестает двигаться в сторону, когда кнопка направления отпущена;
- машина выезжает за границы дороги и игрового поля.
Чтобы это исправить, нужно реализовать поведение машины при отпускании клавиш RIGHT и LEFT.
Переопредели метод onKeyReleased(Key) и в нём устанавливай машине направление Direction.NONE, если это необходимо.
Для регулировки дорожного движения в пакете road создай класс RoadManager.
В нём создай поля, которые будут хранить x-координаты границ проезжей части.
Используй их в методе move() класса PlayerCar, чтобы не допустить выезд машины за пределы дороги.
Если проверять границы дороги до изменения координаты x машины игрока, она сможет выезжать одним колесом на обочину.
А если сначала изменить х, а потом проверить границы, машина игрока будет строго ограничена трассой.
Выбор за тобой.



Игра Racer (11/28)

По горизонтали машина может двигаться вправо, влево или вообще не двигаться. Чтобы определять эти направления, создай enum Direction
со значениями: RIGHT, LEFT, NONE.
У машины игрока должно быть поле, хранящее направление движения (Direction direction).
Обращаться к нему будем через геттер и сеттер.
В классе PlayerCar создай метод move(), который в зависимости от направления движения будет менять
координаты машины по горизонтали. Вызываться этот метод будет в moveAll().
Чтобы обрабатывать нажатие клавиш, переопредели метод onKeyPress(Key). В зависимости от нажатой клавиши, устанавливай соответствующее
направление машине игрока, используя сеттер.



Игра Racer (11/28)

Прерывистые полосы должны двигаться, создавая эффект движения машины, а сама машина будет всегда находиться внизу игрового экрана.
Добавим машине поле, отвечающее за скорость. Его значение будет передаваться в roadMarking.move(int) и сообщать, насколько быстро нужно двигать разметку.
В RacerGame создадим метод moveAll(), который будет перемещать все подвижные игровые объекты (пока только разметку).
moveAll() должен вызываться каждые 40 мс. Для этого в RacerGame нужно переопределить метод onTurn(int) и задать интервал в методе createGame().
Как работать с onTurn(int) &mdash; можешь прочить в описании движка: https://javarush.ru/groups/posts/2056-razdel-igrih-na-javarush-chastjh-3-obrabotka-sobihtiy



Игра Racer (11/28)

Сейчас займемся созданием машины игрока.
Для этого создадим класс PlayerCar и унаследуем его от GameObject.
Вначале машина игрока будет находиться в третьей по счету полосе движения и на одну позицию выше нижнего края игрового поля.
Поэтому координата x будет равняться RacerGame.WIDTH/2 + 2, а y &mdash; RacerGame.HEIGHT - playerCarHeight - 1.
Матрица для машины уже есть в ShapeMatrix.
Для обращения к машине игрока, экземпляр класса PlayerCar должен храниться в переменной player класса RacerGame.
Чтобы увидеть машину на игровом поле, вызови у нее метод draw(Game).



Игра Racer (11/28)

Дорожное полотно, обочина и сплошная разделительная полоса &mdash; статические объекты: они не будут двигаться.
Эффект движения будет создаваться другими игровыми объектами. Пока машины у нас отсутствуют, двигаться будут только две прерывистые полосы на дороге.
Дополнительная дорожная разметка будет представляться отдельным объектом. Создавать ее не нужно &ndash; класс RoadMarking есть у тебя в пакете с игрой.
Просмотри код этого класса. Кроме конструктора, RoadMarking содержит еще 2 метода: move(int) - отвечает за передвижение и draw(Game) - за отрисовку объекта.
На данном этапе займемся только отрисовкой. В качестве аргумента метод draw(Game) принимает объект, на котором должен отрисоваться.
В нашем случае это текущий экземпляр класса RacerGame (this).
Также у тебя появился класс ShapeMatrix, который хранит числовые матрицы изображения игровых объектов. Числа в матрице означают порядковый номер цвета в enum Color.
Благодаря числовой матрице изображения, объект будет знать, в какой цвет раскрасить каждую координату.
Сейчас в ShapeMatrix находится матрица только для прерывистых полос дорожной разметки, но в будущем туда будут добавляться и другие модели изображения объектов.

Добавь в RacerGame поле типа RoadMarking, инициализируй его в методе createGame() и отрисуй в методе drawScene().
Отрисовка прерывистой полосы должна происходить после отрисовки (поверх) статических объектов.




