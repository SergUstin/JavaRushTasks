taskKey="com.javarush.games.racer.part10"\n\nИгра Racer (10/28)

На данный момент поведение машины не совсем соответствует ожидаемому:
- машина не перестает двигаться в сторону, когда кнопка направления отпущена;
- машина выезжает за границы дороги и игрового поля.
Чтобы это исправить, нужно реализовать поведение машины при отпускании клавиш RIGHT и LEFT.
Переопредели метод onKeyReleased(Key) и в нём устанавливай машине направление Direction.NONE, если это необходимо.
Для регулировки дорожного движения в пакете road создай класс RoadManager.
В нём создай поля, которые будут хранить x-координаты границ проезжей части.
Используй их в методе move() класса PlayerCar, чтобы не допустить выезд машины за пределы дороги.
Если проверять границы дороги до изменения координаты x машины игрока, она сможет выезжать одним колесом на обочину.
А если сначала изменить х, а потом проверить границы, машина игрока будет строго ограничена трассой.
Выбор за тобой.


Требования:
1.	В классе RacerGame должен быть переопределен метод onKeyReleased(Key) родительского класса Game.
2.	Метод onKeyReleased(Key) должен устанавливать игроку направление Direction.NONE, если параметр метода равен Key.RIGHT и направление движения игрока равно Direction.RIGHT.
3.	Метод onKeyReleased(Key) должен устанавливать игроку направление Direction.NONE, если параметр метода равен Key.LEFT и направление движения игрока равное Direction.LEFT.
4.	В пакете road в отдельном файле должен существовать публичный класс RoadManager.
5.	В классе RoadManager должно существовать публичное статическое final int поле LEFT_BORDER, проинициализированное при объявлении значением RacerGame.ROADSIDE_WIDTH.
6.	В классе RoadManager должно существовать публичное статическое final int поле RIGHT_BORDER, проинициализированное при объявлении значением RacerGame.WIDTH - LEFT_BORDER.
7.	Метод move() класса PlayerCar должен устанавливать значение полю x, равное RoadManager.LEFT_BORDER, если x &lt; RoadManager.LEFT_BORDER.
8.	Метод move() класса PlayerCar должен устанавливать значение полю x, равное RoadManager.RIGHT_BORDER - width, если x &gt; RoadManager.RIGHT_BORDER - width.


Игра Racer (10/28)

По горизонтали машина может двигаться вправо, влево или вообще не двигаться. Чтобы определять эти направления, создай enum Direction
со значениями: RIGHT, LEFT, NONE.
У машины игрока должно быть поле, хранящее направление движения (Direction direction).
Обращаться к нему будем через геттер и сеттер.
В классе PlayerCar создай метод move(), который в зависимости от направления движения будет менять
координаты машины по горизонтали. Вызываться этот метод будет в moveAll().
Чтобы обрабатывать нажатие клавиш, переопредели метод onKeyPress(Key). В зависимости от нажатой клавиши, устанавливай соответствующее
направление машине игрока, используя сеттер.



Игра Racer (10/28)

Прерывистые полосы должны двигаться, создавая эффект движения машины, а сама машина будет всегда находиться внизу игрового экрана.
Добавим машине поле, отвечающее за скорость. Его значение будет передаваться в roadMarking.move(int) и сообщать, насколько быстро нужно двигать разметку.
В RacerGame создадим метод moveAll(), который будет перемещать все подвижные игровые объекты (пока только разметку).
moveAll() должен вызываться каждые 40 мс. Для этого в RacerGame нужно переопределить метод onTurn(int) и задать интервал в методе createGame().
Как работать с onTurn(int) &mdash; можешь прочить в описании движка: https://javarush.ru/groups/posts/2056-razdel-igrih-na-javarush-chastjh-3-obrabotka-sobihtiy



Игра Racer (10/28)

Сейчас займемся созданием машины игрока.
Для этого создадим класс PlayerCar и унаследуем его от GameObject.
Вначале машина игрока будет находиться в третьей по счету полосе движения и на одну позицию выше нижнего края игрового поля.
Поэтому координата x будет равняться RacerGame.WIDTH/2 + 2, а y &mdash; RacerGame.HEIGHT - playerCarHeight - 1.
Матрица для машины уже есть в ShapeMatrix.
Для обращения к машине игрока, экземпляр класса PlayerCar должен храниться в переменной player класса RacerGame.
Чтобы увидеть машину на игровом поле, вызови у нее метод draw(Game).



Игра Racer (10/28)

Дорожное полотно, обочина и сплошная разделительная полоса &mdash; статические объекты: они не будут двигаться.
Эффект движения будет создаваться другими игровыми объектами. Пока машины у нас отсутствуют, двигаться будут только две прерывистые полосы на дороге.
Дополнительная дорожная разметка будет представляться отдельным объектом. Создавать ее не нужно &ndash; класс RoadMarking есть у тебя в пакете с игрой.
Просмотри код этого класса. Кроме конструктора, RoadMarking содержит еще 2 метода: move(int) - отвечает за передвижение и draw(Game) - за отрисовку объекта.
На данном этапе займемся только отрисовкой. В качестве аргумента метод draw(Game) принимает объект, на котором должен отрисоваться.
В нашем случае это текущий экземпляр класса RacerGame (this).
Также у тебя появился класс ShapeMatrix, который хранит числовые матрицы изображения игровых объектов. Числа в матрице означают порядковый номер цвета в enum Color.
Благодаря числовой матрице изображения, объект будет знать, в какой цвет раскрасить каждую координату.
Сейчас в ShapeMatrix находится матрица только для прерывистых полос дорожной разметки, но в будущем туда будут добавляться и другие модели изображения объектов.

Добавь в RacerGame поле типа RoadMarking, инициализируй его в методе createGame() и отрисуй в методе drawScene().
Отрисовка прерывистой полосы должна происходить после отрисовки (поверх) статических объектов.




Игра Racer (10/28)

Для представления игровых объектов создай класс GameObject. У всех игровых объектов будут общие черты:
- координаты (int x, int y) &mdash; координаты верхнего левого угла объекта на игровом поле;
- матрица отображения игрового объекта (int[][] matrix). Значения матрицы &mdash; порядковые номера цветов в Color.
Чтобы получить цвет, нужно использовать Color.values()[matrix[i][j]], где:
i &mdash; координата y в матрице matrix,
j &mdash; координата x в матрице matrix.
- высота и ширина (int height, int width). Высота и ширина соответствуют размерам матрицы.
Также у объекта должен существовать метод, который его рисует.



