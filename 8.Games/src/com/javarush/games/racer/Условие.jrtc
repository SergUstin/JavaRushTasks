taskKey="com.javarush.games.racer.part09"\n\nИгра Racer (9/28)

По горизонтали машина может двигаться вправо, влево или вообще не двигаться. Чтобы определять эти направления, создай enum Direction
со значениями: RIGHT, LEFT, NONE.
У машины игрока должно быть поле, хранящее направление движения (Direction direction).
Обращаться к нему будем через геттер и сеттер.
В классе PlayerCar создай метод move(), который в зависимости от направления движения будет менять
координаты машины по горизонтали. Вызываться этот метод будет в moveAll().
Чтобы обрабатывать нажатие клавиш, переопредели метод onKeyPress(Key). В зависимости от нажатой клавиши, устанавливай соответствующее
направление машине игрока, используя сеттер.


Требования:
1.	В отдельном файле должен существовать публичный enum Direction со значениями: NONE, RIGHT, LEFT.
2.	В классе PlayerCar должно существовать приватное поле direction типа Direction.
3.	В классе PlayerCar должен существовать публичный сеттер void setDirection(Direction), который устанавливает значение полю direction.
4.	В классе PlayerCar должен существовать публичный геттер Direction getDirection(), который возвращает значение поля direction.
5.	В классе PlayerCar должен существовать публичный метод void move().
6.	В методе move() класса PlayerCar, если значение поля direction равно Direction.LEFT, необходимо уменьшить координату x на единицу.
7.	В методе move() класса PlayerCar, если значение поля direction равно Direction.RIGHT, необходимо увеличить координату x на единицу.
8.	В методе moveAll() класса RacerGame у объекта player должен быть вызван метод move().
9.	В классе RacerGame должен быть переопределен метод onKeyPress(Key) родительского класса Game.
10.	Метод onKeyPress(Key) должен задавать игроку направление Direction.RIGHT, если параметр метода равен Key.RIGHT.
11.	Метод onKeyPress(Key) должен задавать игроку направление Direction.LEFT, если параметр метода равен Key.LEFT.


Игра Racer (9/28)

Прерывистые полосы должны двигаться, создавая эффект движения машины, а сама машина будет всегда находиться внизу игрового экрана.
Добавим машине поле, отвечающее за скорость. Его значение будет передаваться в roadMarking.move(int) и сообщать, насколько быстро нужно двигать разметку.
В RacerGame создадим метод moveAll(), который будет перемещать все подвижные игровые объекты (пока только разметку).
moveAll() должен вызываться каждые 40 мс. Для этого в RacerGame нужно переопределить метод onTurn(int) и задать интервал в методе createGame().
Как работать с onTurn(int) &mdash; можешь прочить в описании движка: https://javarush.ru/groups/posts/2056-razdel-igrih-na-javarush-chastjh-3-obrabotka-sobihtiy



Игра Racer (9/28)

Сейчас займемся созданием машины игрока.
Для этого создадим класс PlayerCar и унаследуем его от GameObject.
Вначале машина игрока будет находиться в третьей по счету полосе движения и на одну позицию выше нижнего края игрового поля.
Поэтому координата x будет равняться RacerGame.WIDTH/2 + 2, а y &mdash; RacerGame.HEIGHT - playerCarHeight - 1.
Матрица для машины уже есть в ShapeMatrix.
Для обращения к машине игрока, экземпляр класса PlayerCar должен храниться в переменной player класса RacerGame.
Чтобы увидеть машину на игровом поле, вызови у нее метод draw(Game).



Игра Racer (9/28)

Дорожное полотно, обочина и сплошная разделительная полоса &mdash; статические объекты: они не будут двигаться.
Эффект движения будет создаваться другими игровыми объектами. Пока машины у нас отсутствуют, двигаться будут только две прерывистые полосы на дороге.
Дополнительная дорожная разметка будет представляться отдельным объектом. Создавать ее не нужно &ndash; класс RoadMarking есть у тебя в пакете с игрой.
Просмотри код этого класса. Кроме конструктора, RoadMarking содержит еще 2 метода: move(int) - отвечает за передвижение и draw(Game) - за отрисовку объекта.
На данном этапе займемся только отрисовкой. В качестве аргумента метод draw(Game) принимает объект, на котором должен отрисоваться.
В нашем случае это текущий экземпляр класса RacerGame (this).
Также у тебя появился класс ShapeMatrix, который хранит числовые матрицы изображения игровых объектов. Числа в матрице означают порядковый номер цвета в enum Color.
Благодаря числовой матрице изображения, объект будет знать, в какой цвет раскрасить каждую координату.
Сейчас в ShapeMatrix находится матрица только для прерывистых полос дорожной разметки, но в будущем туда будут добавляться и другие модели изображения объектов.

Добавь в RacerGame поле типа RoadMarking, инициализируй его в методе createGame() и отрисуй в методе drawScene().
Отрисовка прерывистой полосы должна происходить после отрисовки (поверх) статических объектов.




Игра Racer (9/28)

Для представления игровых объектов создай класс GameObject. У всех игровых объектов будут общие черты:
- координаты (int x, int y) &mdash; координаты верхнего левого угла объекта на игровом поле;
- матрица отображения игрового объекта (int[][] matrix). Значения матрицы &mdash; порядковые номера цветов в Color.
Чтобы получить цвет, нужно использовать Color.values()[matrix[i][j]], где:
i &mdash; координата y в матрице matrix,
j &mdash; координата x в матрице matrix.
- высота и ширина (int height, int width). Высота и ширина соответствуют размерам матрицы.
Также у объекта должен существовать метод, который его рисует.



Игра Racer (9/28)

В процессе игры появятся много объектов, которые будут двигаться по игровому полю и иногда его покидать.
В случае вызова метода setCellColor(int, int, Color) с координатами, лежащими за пределами игрового поля, будет выбрасываться исключение.
Чтобы этого не произошло, переопредели его таким образом, чтобы вызов родительского метода происходил только с координатами, лежащими на игровом поле.
Подсказка: для вызова родительского метода используй ключевое слово super.



