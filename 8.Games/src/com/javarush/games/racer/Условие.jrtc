taskKey="com.javarush.games.racer.part21"\n\nИгра Racer (21/28)

Давай немного усложним игру.
Добавим машину с &quot;пьяным&quot; водителем.
Для ее представления на игровом поле в пакет road был добавлен новый класс MovingCar. Используй его для создания таких машин.
В отличие от обычных машин, &quot;пьяный&quot; водитель будет двигаться и по горизонтали.
Чтобы он не пересекался с другими машинами, в методе move() класса MovingCar, происходит проверка таких пересечений.
Для этого в метод move(int boost), кроме скорости, нужно еще передавать список всех объектов-препятствий.

Еще одна тонкость заключается в том, что MovingCar &mdash; наследник класса RoadObject, и переопределяет его метод move,
поэтому необходимо добавить второй аргумент и методу move в родительском классе.

При большом количестве &quot;пьяных&quot; водителей на трассе игра станет слишком сложной, поэтому позаботься о том,
чтобы на трассе одновременно была только одна такая машина.
Для проверки этого реализуй метод isMovingCarExists() по аналогии с методом isThornExists().

За генерацию MovingCar будет отвечать отдельный метод void generateMovingCar(Game).
Его реализация аналогична реализации метода generateThorn(Game).


Требования:
1.	В классе RoadObject метод void move() должен принимать два параметра: скорость движения и список RoadObject-ов.
2.	В классе RoadManager в методе void move(int boost) у объектов типа RoadObject должен вызываться метод move() с двумя параметрами: первый &mdash; сумма boost и скорости текущего объекта, второй &mdash; список items.
3.	Метод createRoadObject(RoadObjectType, int, int) класса RoadManager должен вернуть новый объект типа MovingCar, если type равен RoadObjectType.DRUNK_CAR.
4.	В классе RoadManager должен существовать приватный метод boolean isMovingCarExists().
5.	Метод isMovingCarExists() должен возвращать true, если в списке items есть объект типа MovingCar. Иначе &mdash; false.
6.	В классе RoadManager должен существовать приватный метод void generateMovingCar(Game).
7.	В методе generateMovingCar(Game game) у объекта game необходимо вызвать метод getRandomNumber(int) с параметром 100.
8.	В методе generateMovingCar(Game game), если метод getRandomNumber(int) вернул меньше 10 и метод isMovingCarExists() вернул false, необходимо вызвать метод addRoadObject(RoadObjectType, Game) с параметрами: RoadObjectType.DRUNK_CAR, game.
9.	В методе generateNewRoadObjects(Game) класса RoadManager необходимо вызвать метод generateMovingCar(Game).


Игра Racer (21/28)

Сейчас встречных машин слишком много.
Чтобы игру можно было пройти, промежутки между препятствиями должны быть достаточно большими.
С другой стороны, если они будут слишком большие, игра станет очень простой и не такой интересной.
Оптимальным расстоянием будет 12: оно соответствует габаритам машины игрока с небольшим запасом.
Это значение будем хранить в константе PLAYER_CAR_DISTANCE.

Реализуй метод boolean isRoadSpaceFree(RoadObject object), который будет проверять,
есть ли достаточно свободного места на дороге для размещения новой машины.
В этом тебе поможет метод isCollisionWithDistance(GameObject, int). Этот метод возвращает false,
если расстояние между объектами по горизонтали и вертикали больше переданной дистанции.
Если на дороге есть свободное место, добавляй новую машину в items.



Игра Racer (21/28)

Кроме шипов, на трассе неплохо бы смотрелись машины разных типов.
Для представления машин на игровом поле создай в пакете road общий для всех типов машин класс Car и унаследуй его от RoadObject.
Все машины будут двигаться со скоростью 1.

Так как метод createRoadObject(RoadObjectType, int, int) класса RoadManager отвечает за создание всех дорожных объектов,
вместо null он должен возвращать новый объект типа Car.
Для генерации новых машин создай метод generateRegularCar(Game game) в классе RoadManager.
Чтобы трасса не была слишком загружена, новая машина должна создаваться с вероятностью 30%.
Тип машины должен быть случайно выбран из первых четырех элементов RoadObjectType.
Не забудь каждую созданную машину добавить в список items.



Игра Racer (21/28)

После завершения игры должна быть возможность начать заново. Реализуй перезапуск игры по нажатию клавиши SPACE.

Чтобы игрок мог быстрее преодолеть трассу, его машина должна иметь возможность увеличивать скорость.
Реализуй увеличение скорости в 2 раза по нажатию клавиши UP, а при отпускании этой клавиши &mdash; возвращение к начальной скорости.



Игра Racer (21/28)

Игра должна останавливаться в двух случаях: когда игрок выиграл или проиграл. Пока реализуем остановку только для проигрышей.
Для хранения текущего состояния игры создадим поле boolean isGameStopped, начальное состояние которого должно быть false.
Когда игрок сталкивается с препятствием &mdash; он проиграл, а значит игра должна остановиться, а на экран &mdash; вывестись сообщение, например, GAME OVER.
Все действия, которые осуществляются при проигрыше, удобно вынести в отдельный метод gameOver().
В методе onTurn(int) нужно проверять пересечение игрока с препятствиями (метод checkCrush(PlayerCar)).



Игра Racer (21/28)

На данный момент при пересечении с препятствием машина игрока продолжает движение.
В этой части реализуем метод, который будет проверять, столкнулась ли машина с преградой.
При реализации этого метода используй метод isCollision(GameObject) класса GameObject, который мы реализовали вместо тебя. Разберись как он работает.

Столкновение должно быть визуально заметно, то есть необходимо изменить изображение машины игрока.
Для этого в класс PlayerCar добавь метод stop(), который будет устанавливать полю matrix значение ShapeMatrix.PLAYER_DEAD.



