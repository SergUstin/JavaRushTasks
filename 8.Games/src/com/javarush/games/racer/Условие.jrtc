taskKey="com.javarush.games.racer.part14"\n\nИгра Racer (14/28)

Пришло время отображать шипы на экране.

На трассе должно быть не больше одного объекта Thorn одновременно.
Для проверки этого условия создай метод isThornExists() в классе RoadManager.
Чтобы проверить, является ли объект RoadObject шипами, можно использовать его поле type.

За генерацию шипов будет отвечать отдельный метод void generateThorn(Game).
Он будет проверять, есть ли на дороге шипы, и если их нет &mdash; генерировать новые с вероятностью 10%.

В будущем препятствиями будут не только шипы. Для генерации всех препятствий потребуется метод generateNewRoadObjects(Game),
но пока он будет генерировать только шипы. Он должен вызываться в методе onTurn(int) класса RacerGame.

Также шипы должны передвигаться вместе с трассой в методе moveAll().


Требования:
1.	В классе RoadManager должен существовать приватный метод boolean isThornExists().
2.	Метод isThornExists() должен возвращать true, если в списке items есть шипы. Иначе &mdash; false.
3.	В классе RoadManager должен существовать приватный метод void generateThorn(Game).
4.	У объекта game в методе generateThorn(Game game) нужно вызвать метод getRandomNumber(int) с параметром 100.
5.	В методе generateThorn(Game game), если метод getRandomNumber(int) вернул меньше 10 и в списке items шипов нет, необходимо вызвать метод addRoadObject(RoadObjectType, Game) с параметрами: RoadObjectType.THORN, game.
6.	В классе RoadManager должен существовать публичный метод void generateNewRoadObjects(Game).
7.	В методе generateNewRoadObjects(Game) необходимо вызвать метод generateThorn(Game).
8.	В методе onTurn(int) класса RacerGame у объекта roadManager необходимо вызвать метод generateNewRoadObjects(Game). В качестве параметра передай в метод &laquo;this&raquo;.
9.	В методе onTurn(int) класса RacerGame метод generateNewRoadObjects(Game) объекта roadManager должен вызываться до drawScene().
10.	В методе moveAll() класса RacerGame у объекта roadManager должен быть вызван метод move(int). В качестве параметра передай в метод скорость игрока.


Игра Racer (14/28)

Класс RoadManager носит такое название не просто так: он управляет всеми препятствиями на дороге.
Он должен уметь прорисовывать (draw) и передвигать (move) все хранимые объекты.

В классе RacerGame создай поле RoadManager roadManager, чтобы была возможность обращаться к нему.
Поле roadManager инициализируй в createGame(), а в drawScene() вызови у него draw(Game).



Игра Racer (14/28)

Объекты-препятствия должны появляться в пределах проезжей части в случайной позиции.

В классе RoadManager введи две константы: FIRST_LANE_POSITION и FOURTH_LANE_POSITION &mdash; крайняя левая и крайняя правая
позиции координат x матриц объектов-препятствий на проезжей части. Присвой им значения 16 и 44 соответственно.

Также в классе RoadManager должен существовать список всех текущих объектов-препятствий.

В этом же классе создай метод addRoadObject(RoadObjectType, Game), который будет генерировать позицию нового препятствия
и добавлять его в список всех объектов-препятствий. Координаты препятствия должны генерироваться следующим образом:
x = game.getRandomNumber(FIRST_LANE_POSITION, FOURTH_LANE_POSITION) &mdash; случайное число в пределах проезжей части;
y = -1 * RoadObject.getHeight(type) &mdash; изначально объект располагается за пределами игрового поля, чтобы появиться плавно.



Игра Racer (14/28)

На пути игрока будут различные препятствия: другие машины, едущие навстречу, и шипы, неподвижные относительно трассы.
Эти препятствия будут наследоваться от класса RoadObject. Типы всех возможных препятствий перечислены в enum RoadObjectType.
Эти классы появились у тебя в пакете road. А класс ShapeMatrix пополнился новыми матрицами для отображения препятствий.
Просмотри класс RoadObject и его методы.

На этом этапе займемся шипами. Создай класс Thorn (шипы) и унаследуй его от RoadObject.
Для создания объектов-препятствий в классе RoadManager создай метод private RoadObject createRoadObject(RoadObjectType type, int x, int y),
который в зависимости от полученных параметров будет создавать и возвращать новое препятствие.
Пока у нас есть единственный тип препятствий &mdash; Thorn, поэтому если метод createRoadObject получит в качестве аргумента какой-то другой тип, он должен вернуть null.
Зная тип игрового объекта, не нужно передавать ему матрицу изображения в конструкторе, поэтому в классе GameObject понадобится еще один конструктор с двумя параметрами:
int x, int y, который устанавливает соответствующие значения полям x, y.



Игра Racer (14/28)

На данный момент поведение машины не совсем соответствует ожидаемому:
- машина не перестает двигаться в сторону, когда кнопка направления отпущена;
- машина выезжает за границы дороги и игрового поля.
Чтобы это исправить, нужно реализовать поведение машины при отпускании клавиш RIGHT и LEFT.
Переопредели метод onKeyReleased(Key) и в нём устанавливай машине направление Direction.NONE, если это необходимо.
Для регулировки дорожного движения в пакете road создай класс RoadManager.
В нём создай поля, которые будут хранить x-координаты границ проезжей части.
Используй их в методе move() класса PlayerCar, чтобы не допустить выезд машины за пределы дороги.
Если проверять границы дороги до изменения координаты x машины игрока, она сможет выезжать одним колесом на обочину.
А если сначала изменить х, а потом проверить границы, машина игрока будет строго ограничена трассой.
Выбор за тобой.



Игра Racer (14/28)

По горизонтали машина может двигаться вправо, влево или вообще не двигаться. Чтобы определять эти направления, создай enum Direction
со значениями: RIGHT, LEFT, NONE.
У машины игрока должно быть поле, хранящее направление движения (Direction direction).
Обращаться к нему будем через геттер и сеттер.
В классе PlayerCar создай метод move(), который в зависимости от направления движения будет менять
координаты машины по горизонтали. Вызываться этот метод будет в moveAll().
Чтобы обрабатывать нажатие клавиш, переопредели метод onKeyPress(Key). В зависимости от нажатой клавиши, устанавливай соответствующее
направление машине игрока, используя сеттер.



