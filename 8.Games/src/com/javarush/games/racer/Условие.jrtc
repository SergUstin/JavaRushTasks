taskKey="com.javarush.games.racer.part17"\n\nИгра Racer (17/28)

Игра должна останавливаться в двух случаях: когда игрок выиграл или проиграл. Пока реализуем остановку только для проигрышей.
Для хранения текущего состояния игры создадим поле boolean isGameStopped, начальное состояние которого должно быть false.
Когда игрок сталкивается с препятствием &mdash; он проиграл, а значит игра должна остановиться, а на экран &mdash; вывестись сообщение, например, GAME OVER.
Все действия, которые осуществляются при проигрыше, удобно вынести в отдельный метод gameOver().
В методе onTurn(int) нужно проверять пересечение игрока с препятствиями (метод checkCrush(PlayerCar)).


Требования:
1.	В классе RacerGame должно существовать приватное поле isGameStopped типа boolean.
2.	Поле isGameStopped должно быть проинициализировано значением false в методе createGame().
3.	В классе RacerGame должен существовать приватный метод void gameOver().
4.	В методе gameOver() необходимо установить полю isGameStopped значение true.
5.	В методе gameOver() должен вызываться метод showMessageDialog(Color, String, Color, int).
6.	В методе gameOver() должен вызываться метод stopTurnTimer().
7.	В методе gameOver() у объекта player должен вызываться метод stop().
8.	В методе onTurn(int) класса RacerGame у объекта roadManager необходимо вызвать метод checkCrush(PlayerCar) до вызова метода moveAll().
9.	В методе onTurn(int) класса RacerGame, если метод checkCrush(PlayerCar) вернул true, необходимо вызвать метод gameOver().
10.	В методе onTurn(int) класса RacerGame, если метод checkCrush(PlayerCar) вернул true, необходимо вызвать метод drawScene() после метода gameOver() и больше ничего не делать.


Игра Racer (17/28)

На данный момент при пересечении с препятствием машина игрока продолжает движение.
В этой части реализуем метод, который будет проверять, столкнулась ли машина с преградой.
При реализации этого метода используй метод isCollision(GameObject) класса GameObject, который мы реализовали вместо тебя. Разберись как он работает.

Столкновение должно быть визуально заметно, то есть необходимо изменить изображение машины игрока.
Для этого в класс PlayerCar добавь метод stop(), который будет устанавливать полю matrix значение ShapeMatrix.PLAYER_DEAD.



Игра Racer (17/28)

Сейчас шипы появляются только один раз (в начале игры). Чтобы генерировались новые шипы, старые нужно удалять из списка items после того,
как они вышли за пределы экрана. Для удаления можно либо использовать итератор, либо создать копию списка items и проходить по ней циклом,
и если объект нужно удалить из списка &mdash; вызывать items.remove(item).



Игра Racer (17/28)

Пришло время отображать шипы на экране.

На трассе должно быть не больше одного объекта Thorn одновременно.
Для проверки этого условия создай метод isThornExists() в классе RoadManager.
Чтобы проверить, является ли объект RoadObject шипами, можно использовать его поле type.

За генерацию шипов будет отвечать отдельный метод void generateThorn(Game).
Он будет проверять, есть ли на дороге шипы, и если их нет &mdash; генерировать новые с вероятностью 10%.

В будущем препятствиями будут не только шипы. Для генерации всех препятствий потребуется метод generateNewRoadObjects(Game),
но пока он будет генерировать только шипы. Он должен вызываться в методе onTurn(int) класса RacerGame.

Также шипы должны передвигаться вместе с трассой в методе moveAll().



Игра Racer (17/28)

Класс RoadManager носит такое название не просто так: он управляет всеми препятствиями на дороге.
Он должен уметь прорисовывать (draw) и передвигать (move) все хранимые объекты.

В классе RacerGame создай поле RoadManager roadManager, чтобы была возможность обращаться к нему.
Поле roadManager инициализируй в createGame(), а в drawScene() вызови у него draw(Game).



Игра Racer (17/28)

Объекты-препятствия должны появляться в пределах проезжей части в случайной позиции.

В классе RoadManager введи две константы: FIRST_LANE_POSITION и FOURTH_LANE_POSITION &mdash; крайняя левая и крайняя правая
позиции координат x матриц объектов-препятствий на проезжей части. Присвой им значения 16 и 44 соответственно.

Также в классе RoadManager должен существовать список всех текущих объектов-препятствий.

В этом же классе создай метод addRoadObject(RoadObjectType, Game), который будет генерировать позицию нового препятствия
и добавлять его в список всех объектов-препятствий. Координаты препятствия должны генерироваться следующим образом:
x = game.getRandomNumber(FIRST_LANE_POSITION, FOURTH_LANE_POSITION) &mdash; случайное число в пределах проезжей части;
y = -1 * RoadObject.getHeight(type) &mdash; изначально объект располагается за пределами игрового поля, чтобы появиться плавно.



