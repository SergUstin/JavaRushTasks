taskKey="com.javarush.games.racer.part25"\n\nИгра Racer (25/28)

В этой части добавим панель прогресса в прохождении игры.
Заметь, у тебя появился новый класс ProgressBar. Разберись как он работает и что делает.
Для хранения экземпляра класса ProgressBar понадобится соответствующее поле в основном классе игры,
которое будет инициализироваться при старте новой игры.
Размер панели будет зависеть от количества машин, которые необходимо пройти. Это значение передается в конструктор.

Наша панель будет перерисовываться каждый такт игры, а индикатор на панели будет двигаться в зависимости от количества пройденных машин-препятствий.


Требования:
1.	В классе RacerGame должно существовать приватное поле progressBar типа ProgressBar.
2.	Поле progressBar должно быть проинициализировано в методе createGame() новым объектом типа ProgressBar до вызова метода drawScene(). В конструктор необходимо передать параметр RACE_GOAL_CARS_COUNT.
3.	В методе drawScene() у объекта progressBar должен быть вызван метод draw(Game). В качестве параметра передай в метод this.
4.	В методе drawScene() метод draw(Game) у объекта progressBar должен быть вызван после метода drawField().
5.	В методе moveAll() у объекта progressBar должен быть вызван метод move(int). В качестве параметра метода, должен передаваться результат выполнения roadManager.getPassedCarsCount().


Игра Racer (25/28)

Чтобы проверять выполнение условий победы, нам нужно будет знать реальное количество машин, с которыми разминулся игрок.
Для этого создай поле passedCarsCount в классе RoadManager и геттер к нему.
Значение этого поля должно увеличиваться на единицу после прохождения каждой машины-препятствия (удаления машины из списка items).

Сравнивать passedCarsCount и RACE_GOAL_CARS_COUNT будем в методе onTurn(int).
Если значение passedCarsCount больше или равно RACE_GOAL_CARS_COUNT, значит цель достигнута и нужно показать финишную линию.



Игра Racer (25/28)

В этой части реализуем прорисовку и движение финишной линии. Для этого ее экземпляр должен храниться в основном классе игры и пересоздаваться при старте новой игры.
Методы draw(Game) и move(int) экземпляра класса FinishLine, как и у всех объектов, будут вызываться каждые 40мс, но результат их вызова будет игнорироваться до вызова метода show().
Также давай определимся с условиями победы. Чтобы прохождение игры было достаточно сложным и интересным, победа должна наступать после преодоления 40 машин-препятствий.
Будем хранить это значение в константе RACE_GOAL_CARS_COUNT.



Игра Racer (25/28)

Приступим к созданию финишной линии. Матрица для нее уже есть в ShapeMatrix.
Финишная линия появится на трассе в конце игры.
На самом деле объект финишной линии создается в начале игры, но находится выше игрового поля, поэтому невидим.
Как только флаг, ответственный за отображение FinishLine, получит значение true, финишная линия начнет движение вниз и появится на игровом поле.



Игра Racer (25/28)

Давай немного усложним игру.
Добавим машину с &quot;пьяным&quot; водителем.
Для ее представления на игровом поле в пакет road был добавлен новый класс MovingCar. Используй его для создания таких машин.
В отличие от обычных машин, &quot;пьяный&quot; водитель будет двигаться и по горизонтали.
Чтобы он не пересекался с другими машинами, в методе move() класса MovingCar, происходит проверка таких пересечений.
Для этого в метод move(int boost), кроме скорости, нужно еще передавать список всех объектов-препятствий.

Еще одна тонкость заключается в том, что MovingCar &mdash; наследник класса RoadObject, и переопределяет его метод move,
поэтому необходимо добавить второй аргумент и методу move в родительском классе.

При большом количестве &quot;пьяных&quot; водителей на трассе игра станет слишком сложной, поэтому позаботься о том,
чтобы на трассе одновременно была только одна такая машина.
Для проверки этого реализуй метод isMovingCarExists() по аналогии с методом isThornExists().

За генерацию MovingCar будет отвечать отдельный метод void generateMovingCar(Game).
Его реализация аналогична реализации метода generateThorn(Game).



Игра Racer (25/28)

Сейчас встречных машин слишком много.
Чтобы игру можно было пройти, промежутки между препятствиями должны быть достаточно большими.
С другой стороны, если они будут слишком большие, игра станет очень простой и не такой интересной.
Оптимальным расстоянием будет 12: оно соответствует габаритам машины игрока с небольшим запасом.
Это значение будем хранить в константе PLAYER_CAR_DISTANCE.

Реализуй метод boolean isRoadSpaceFree(RoadObject object), который будет проверять,
есть ли достаточно свободного места на дороге для размещения новой машины.
В этом тебе поможет метод isCollisionWithDistance(GameObject, int). Этот метод возвращает false,
если расстояние между объектами по горизонтали и вертикали больше переданной дистанции.
Если на дороге есть свободное место, добавляй новую машину в items.



