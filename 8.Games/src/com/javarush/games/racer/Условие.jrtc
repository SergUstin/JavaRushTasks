taskKey="com.javarush.games.racer.part26"\n\nИгра Racer (26/28)

Победа игрока достигается при пересечении финишной линии.
Для проверки пересечения игроком финишной линии, нужно сравнить его координату y с координатой y финишной линии. Если y игрока меньше y финишной линии, значит линия пересечена.
В классе FinishLine создай отдельный метод isCrossed(PlayerCar) для сравнения y-координат.
Вызывать метод isCrossed(PlayerCar) нужно на каждом шаге игры. При пересечении финишной линии необходимо остановить игру и сообщить игроку о победе.
Реализуй это в методе win().


Требования:
1.	В классе FinishLine должен существовать публичный метод boolean isCrossed(PlayerCar).
2.	Метод isCrossed(PlayerCar player) должен возвращать true, если игрок уже пересек финишную линию. Иначе &mdash; false.
3.	В классе RacerGame должен существовать приватный метод void win().
4.	В методе win() необходимо установить полю isGameStopped значение true.
5.	В методе win() должен вызываться метод showMessageDialog(Color, String, Color, int).
6.	В методе win() должен вызываться метод stopTurnTimer().
7.	В методе onTurn(int) класса RacerGame у объекта finishLine необходимо вызвать метод isCrossed(PlayerCar) до moveAll().
8.	В методе onTurn(int) класса RacerGame, необходимо вызвать метод win(), если метод isCrossed(PlayerCar) вернул true.
9.	В методе onTurn(int) класса RacerGame, если метод isCrossed(PlayerCar) вернул true, необходимо вызвать метод drawScene() после метода win() и больше ничего не делать.


Игра Racer (26/28)

В этой части добавим панель прогресса в прохождении игры.
Заметь, у тебя появился новый класс ProgressBar. Разберись как он работает и что делает.
Для хранения экземпляра класса ProgressBar понадобится соответствующее поле в основном классе игры,
которое будет инициализироваться при старте новой игры.
Размер панели будет зависеть от количества машин, которые необходимо пройти. Это значение передается в конструктор.

Наша панель будет перерисовываться каждый такт игры, а индикатор на панели будет двигаться в зависимости от количества пройденных машин-препятствий.



Игра Racer (26/28)

Чтобы проверять выполнение условий победы, нам нужно будет знать реальное количество машин, с которыми разминулся игрок.
Для этого создай поле passedCarsCount в классе RoadManager и геттер к нему.
Значение этого поля должно увеличиваться на единицу после прохождения каждой машины-препятствия (удаления машины из списка items).

Сравнивать passedCarsCount и RACE_GOAL_CARS_COUNT будем в методе onTurn(int).
Если значение passedCarsCount больше или равно RACE_GOAL_CARS_COUNT, значит цель достигнута и нужно показать финишную линию.



Игра Racer (26/28)

В этой части реализуем прорисовку и движение финишной линии. Для этого ее экземпляр должен храниться в основном классе игры и пересоздаваться при старте новой игры.
Методы draw(Game) и move(int) экземпляра класса FinishLine, как и у всех объектов, будут вызываться каждые 40мс, но результат их вызова будет игнорироваться до вызова метода show().
Также давай определимся с условиями победы. Чтобы прохождение игры было достаточно сложным и интересным, победа должна наступать после преодоления 40 машин-препятствий.
Будем хранить это значение в константе RACE_GOAL_CARS_COUNT.



Игра Racer (26/28)

Приступим к созданию финишной линии. Матрица для нее уже есть в ShapeMatrix.
Финишная линия появится на трассе в конце игры.
На самом деле объект финишной линии создается в начале игры, но находится выше игрового поля, поэтому невидим.
Как только флаг, ответственный за отображение FinishLine, получит значение true, финишная линия начнет движение вниз и появится на игровом поле.



Игра Racer (26/28)

Давай немного усложним игру.
Добавим машину с &quot;пьяным&quot; водителем.
Для ее представления на игровом поле в пакет road был добавлен новый класс MovingCar. Используй его для создания таких машин.
В отличие от обычных машин, &quot;пьяный&quot; водитель будет двигаться и по горизонтали.
Чтобы он не пересекался с другими машинами, в методе move() класса MovingCar, происходит проверка таких пересечений.
Для этого в метод move(int boost), кроме скорости, нужно еще передавать список всех объектов-препятствий.

Еще одна тонкость заключается в том, что MovingCar &mdash; наследник класса RoadObject, и переопределяет его метод move,
поэтому необходимо добавить второй аргумент и методу move в родительском классе.

При большом количестве &quot;пьяных&quot; водителей на трассе игра станет слишком сложной, поэтому позаботься о том,
чтобы на трассе одновременно была только одна такая машина.
Для проверки этого реализуй метод isMovingCarExists() по аналогии с методом isThornExists().

За генерацию MovingCar будет отвечать отдельный метод void generateMovingCar(Game).
Его реализация аналогична реализации метода generateThorn(Game).



