taskKey="com.javarush.games.racer.part13"\n\nИгра Racer (13/28)

Класс RoadManager носит такое название не просто так: он управляет всеми препятствиями на дороге.
Он должен уметь прорисовывать (draw) и передвигать (move) все хранимые объекты.

В классе RacerGame создай поле RoadManager roadManager, чтобы была возможность обращаться к нему.
Поле roadManager инициализируй в createGame(), а в drawScene() вызови у него draw(Game).


Требования:
1.	В классе RoadManager должен существовать публичный метод void draw(Game).
2.	В методе draw(Game) класса RoadManager у каждого объекта из списка items необходимо вызвать метод draw(Game).
3.	В классе RoadManager должен существовать публичный метод void move(int boost).
4.	В методе move(int) класса RoadManager у каждого объекта из списка items необходимо вызвать метод move. В качестве параметра передай сумму boost и скорости текущего объекта.
5.	В классе RacerGame должно существовать приватное поле roadManager типа RoadManager.
6.	Поле roadManager должно быть проинициализировано в методе createGame() новым объектом типа RoadManager до вызова метода drawScene().
7.	В методе drawScene() у объекта roadManager должен быть вызван метод draw(Game). В качестве параметра передай в метод this.
8.	У объекта roadManager метод draw(Game) в методе drawScene() должен быть вызван после метода drawField().


Игра Racer (13/28)

Объекты-препятствия должны появляться в пределах проезжей части в случайной позиции.

В классе RoadManager введи две константы: FIRST_LANE_POSITION и FOURTH_LANE_POSITION &mdash; крайняя левая и крайняя правая
позиции координат x матриц объектов-препятствий на проезжей части. Присвой им значения 16 и 44 соответственно.

Также в классе RoadManager должен существовать список всех текущих объектов-препятствий.

В этом же классе создай метод addRoadObject(RoadObjectType, Game), который будет генерировать позицию нового препятствия
и добавлять его в список всех объектов-препятствий. Координаты препятствия должны генерироваться следующим образом:
x = game.getRandomNumber(FIRST_LANE_POSITION, FOURTH_LANE_POSITION) &mdash; случайное число в пределах проезжей части;
y = -1 * RoadObject.getHeight(type) &mdash; изначально объект располагается за пределами игрового поля, чтобы появиться плавно.



Игра Racer (13/28)

На пути игрока будут различные препятствия: другие машины, едущие навстречу, и шипы, неподвижные относительно трассы.
Эти препятствия будут наследоваться от класса RoadObject. Типы всех возможных препятствий перечислены в enum RoadObjectType.
Эти классы появились у тебя в пакете road. А класс ShapeMatrix пополнился новыми матрицами для отображения препятствий.
Просмотри класс RoadObject и его методы.

На этом этапе займемся шипами. Создай класс Thorn (шипы) и унаследуй его от RoadObject.
Для создания объектов-препятствий в классе RoadManager создай метод private RoadObject createRoadObject(RoadObjectType type, int x, int y),
который в зависимости от полученных параметров будет создавать и возвращать новое препятствие.
Пока у нас есть единственный тип препятствий &mdash; Thorn, поэтому если метод createRoadObject получит в качестве аргумента какой-то другой тип, он должен вернуть null.
Зная тип игрового объекта, не нужно передавать ему матрицу изображения в конструкторе, поэтому в классе GameObject понадобится еще один конструктор с двумя параметрами:
int x, int y, который устанавливает соответствующие значения полям x, y.



Игра Racer (13/28)

На данный момент поведение машины не совсем соответствует ожидаемому:
- машина не перестает двигаться в сторону, когда кнопка направления отпущена;
- машина выезжает за границы дороги и игрового поля.
Чтобы это исправить, нужно реализовать поведение машины при отпускании клавиш RIGHT и LEFT.
Переопредели метод onKeyReleased(Key) и в нём устанавливай машине направление Direction.NONE, если это необходимо.
Для регулировки дорожного движения в пакете road создай класс RoadManager.
В нём создай поля, которые будут хранить x-координаты границ проезжей части.
Используй их в методе move() класса PlayerCar, чтобы не допустить выезд машины за пределы дороги.
Если проверять границы дороги до изменения координаты x машины игрока, она сможет выезжать одним колесом на обочину.
А если сначала изменить х, а потом проверить границы, машина игрока будет строго ограничена трассой.
Выбор за тобой.



Игра Racer (13/28)

По горизонтали машина может двигаться вправо, влево или вообще не двигаться. Чтобы определять эти направления, создай enum Direction
со значениями: RIGHT, LEFT, NONE.
У машины игрока должно быть поле, хранящее направление движения (Direction direction).
Обращаться к нему будем через геттер и сеттер.
В классе PlayerCar создай метод move(), который в зависимости от направления движения будет менять
координаты машины по горизонтали. Вызываться этот метод будет в moveAll().
Чтобы обрабатывать нажатие клавиш, переопредели метод onKeyPress(Key). В зависимости от нажатой клавиши, устанавливай соответствующее
направление машине игрока, используя сеттер.



Игра Racer (13/28)

Прерывистые полосы должны двигаться, создавая эффект движения машины, а сама машина будет всегда находиться внизу игрового экрана.
Добавим машине поле, отвечающее за скорость. Его значение будет передаваться в roadMarking.move(int) и сообщать, насколько быстро нужно двигать разметку.
В RacerGame создадим метод moveAll(), который будет перемещать все подвижные игровые объекты (пока только разметку).
moveAll() должен вызываться каждые 40 мс. Для этого в RacerGame нужно переопределить метод onTurn(int) и задать интервал в методе createGame().
Как работать с onTurn(int) &mdash; можешь прочить в описании движка: https://javarush.ru/groups/posts/2056-razdel-igrih-na-javarush-chastjh-3-obrabotka-sobihtiy



