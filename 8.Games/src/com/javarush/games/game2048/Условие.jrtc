taskKey="com.javarush.games.game2048.part16"\n\nИгра 2048 (16/18)

Пришло время узнать, для чего нам нужен флаг isGameStopped. Он необходим для реализации механизма рестарта игры.
Если значение этого флага true &mdash; игра остановлена из-за выигрыша или проигрыша. При нажатии клавиши Key.SPACE можно делать рестарт игры.
Рестарт выполняется так же, как и старт новой игры &mdash; вызовом метода createGame(), который создает новое игровое поле.

Примечание:
Проверку возможности рестарта игры лучше проводить перед проверкой возможности хода.


Требования:
1.	Если игра остановлена, по нажатию клавиши Key.SPACE полю isGameStopped должно присваиваться значение false.
2.	Если игра остановлена, по нажатию клавиши Key.SPACE должен быть вызван метод createGame().
3.	В методе createGame() матрица gameField должна создаваться заново.
4.	Если игра остановлена, по нажатию клавиши Key.SPACE нужно отобразить на экране новое состояние &ndash; вызвать метод drawScene().
5.	Если игра остановлена, нажатие любых других клавиш, кроме Key.SPACE, должно игнорироваться.


Игра 2048 (16/18)

Как и о выигрыше, о проигрыше нужно сообщить. Давай это сделаем в отдельном методе void gameOver(),
по аналогии с методом win(). Если игра проиграна, флагу isGameStopped также нужно установить значение true.

В начале метода onKeyPress(Key) выполни проверку, возможен ли ход. Если ход невозможен, вызови метод gameOver() и больше ничего не делай.



Игра 2048 (16/18)

Отлично! В прошлой части мы выяснили условия, при которых игра выиграна и реализовали их.
Но есть и обратная сторона медали &mdash; проигрыш. Если на игровом поле нет плитки со
значением 2048 и нет возможности сделать ход, игроку засчитывается поражение.

Ход можно сделать, если есть хотя бы одна пустая плитка или пустых плиток нет, но есть возможность их соединения.

Вынеси эти проверки в метод canUserMove().



Игра 2048 (16/18)

Основная логика игры реализована, но не до конца. Исходя из правил и названия игры, она заканчивается
выигрышем, когда значение одной из плиток будет равно 2048.

Поиск максимального значения на игровом поле нужно вынести в отдельный метод int getMaxTileValue(), который будет
возвращать его. Проверку выигрыша можно делать где угодно. Например, в самом начале
метода createNewNumber(), перед добавлением нового значения в матрицу.

Когда найдена плитка со значением 2048, нужно сообщить игроку о выигрыше. Чтобы сделать это красиво, вызови
метод showMessageDialog(Color cellColor, String message, Color textColor, int textSize) класса Game.
Думаю, не нужно объяснять, что передавать в этот метод: названия параметров говорят сами за себя.

После победы текущая игра прекращается. В будущем нам пригодится некий флаг isGameStopped.
Если игра выиграна, он будет равен true.
Давай все вышеописанное (вывод сообщения о выигрыше, флаг остановки игры) вынесем в отдельный метод, который назовем win().



Игра 2048 (16/18)

Теперь можно приступать к реализации методов moveRight(), moveUp(), moveDown().

В методе moveRight() повернем матрицу gameFiled два раза по часовой стрелке, затем вызовем moveLeft(),
который уже написан, и снова повернем gameField еще два раза по часовой стрелке. Должно сработать.

В методе moveDown() поворачиваем на 90 градусов один раз, затем вызываем moveLeft() и еще 3 раза поворачиваем на 90 градусов.

В методе moveUp() сначала поворачиваем на 90 градусов три раза, затем вызываем moveLeft() и еще один раз
поворачиваем на 90 градусов.



Игра 2048 (16/18)

Метод moveLeft() реализован, но есть еще 3. Предлагаем их реализовать таким способом: если нужно сдвинуть плитки
вниз, берем нашу матрицу gameField, поворачиваем ее на 90 градусов по часовой стрелке (низ становится слева),
сдвигаем влево и разворачиваем матрицу обратно (еще 3 раза поворачиваем матрицу на 90 градусов по часовой
стрелке). Остальные методы &mdash; аналогично.

Начнем с поворота матрицы gameField. Вот как примерно это должно выглядеть:
(2, 2, 2, 2), (0, 8, 4, 2),
(4, 4, 4, 4),  (0, 8, 4, 2),
(8, 8, 8, 8), (0, 8, 4, 2),
(0, 0, 0, 0), (0, 8, 4, 2)



