taskKey="com.javarush.games.spaceinvaders.part18"\n\nИгра Space Invaders (18/34)

На данном этапе мы подготовим анимацию для крушения кораблей. Для этого нам понадобится поле frames типа List&lt;int[][]&gt;,
которое будет хранить список матриц для кадров анимации. Также нам понадобится поле frameIndex, которое хранит индекс
текущего кадра анимации. Передавать кадры анимации мы будем в методе setAnimatedView. Он принимает массив
кадров(матриц) и передает их списку frames. В завершение, реализуем метод setStaticView, который задает изначальную матрицу
для кораблей.


Требования:
1.	В классе Ship должно существовать приватное поле frames типа List&lt;int[][]&gt;.
2.	В классе Ship должно существовать приватное поле int frameIndex.
3.	В классе Ship должен существовать публичный метод void setAnimatedView(int[][]... viewFrames).
4.	В методе setAnimatedView(int[][]... viewFrames) необходимо вызвать метод setMatrix(int[][]) базового класса. В качестве параметра передай в метод viewFrames[0].
5.	В методе setAnimatedView(int[][]... viewFrames) поле frames должно быть инициализировано значением Arrays.asList(viewFrames).
6.	В методе setAnimatedView(int[][]... viewFrames) полю frameIndex необходимо установить значение 0.
7.	В методе setStaticView(int[][] viewFrame) поле frames должно быть инициализировано новым объектом типа ArrayList&lt;int[][]&gt;.
8.	В методе setStaticView(int[][] viewFrame) в список frames необходимо добавить объект viewFrame.
9.	В методе setStaticView(int[][]) полю frameIndex необходимо установить значение 0.


Игра Space Invaders (18/34)

Добавим в класс PlayerShip метод, который проверяет, попали ли вражеские пули в корабль игрока (метод isCollision класса GameObject).
Если было попадание, он &quot;убивает&quot; корабль и пулю. Также добавим корабль игрока в класс игры, отрисуем его и внесем проверку попаданий в соответствующий метод.



Игра Space Invaders (18/34)

Теперь создадим корабль игрока. Для этого нам нужен класс PlayerShip. В его конструкторе
будем устанавливать значения координат таким образом, чтобы корабль отображался внизу экрана по центру.
Кроме этого, конструктор задает внешний вид корабля, устанавливая матрицу PLAYER, которую
мы тебе прислали в классе ShapeMatrix. У корабля может быть два состояния: &quot;живой&quot; или &quot;неживой&quot;
Чтобы описать эти состояния, добавим поле isAlive в общий класс кораблей Ship. Когда пуля попадает в корабль,
они (пуля и корабль) уничтожаются, поэтому добавим метод kill. При его вызове будем &quot;убивать&quot;
корабль и пулю.



Игра Space Invaders (18/34)

Все вражеские пули будем хранить в переменной enemyBullets класса SpaceInvadersGame. Добавим их отрисовку
и движение в соответствующие методы. Чтобы удалить потраченные пули, создадим и реализуем
метод removeDeadBullets() в классе SpaceInvadersGame. Для удаления можно либо использовать итератор, либо создать копию списка enemyBullets
и проходить по ней циклом. Если в результате проверки объект нужно удалить из списка, вызываем enemyBullets.remove(bullet).
К потраченным пулям относятся те, которые вылетели за пределы экрана, и те, которые попали в цель (isAlive == false).
Добавим вспомогательный метод check(). На данном этапе он будет вызывать метод removeDeadBullets(). Впоследствии в нем
будут происходить различные проверки на каждом шаге игры.
С такой же частотой мы будем вызывать метод fire() у флота, при котором один из вражеских кораблей может выстрелить.
Если выстрел произошел, метод вернет пулю, которую нужно добавить в список.



Игра Space Invaders (18/34)

Создадим и реализуем метод fire у EnemyFleet. Этот метод будет вызывать метод fire у одного из кораблей флота, выбранного случайно.
Кроме того, флот будет стрелять с вероятностью COMPLEXITY процентов.



Игра Space Invaders (18/34)

Введем переменную COMPLEXITY, которая отвечает за сложность игры, а именно &mdash; за вероятность выстрела
вражеского корабля за один шаг игры. Все корабли должны стрелять, поэтому в класс Ship добавим метод fire. Так как экземпляр
этого класса мы не будем создавать, сделаем этот метод &quot;заглушкой&quot;, а реализовывать его будем в
классах-наследниках. Чтобы пуля вылетала из носовой пушки, нужно передать в конструктор правильные координаты.



