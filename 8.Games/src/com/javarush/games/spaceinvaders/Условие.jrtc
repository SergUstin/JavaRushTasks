taskKey="com.javarush.games.spaceinvaders.part20"\n\nИгра Space Invaders (20/34)

Чтобы переключиться на следующий кадр анимации, в классе Ship создадим метод nextFrame. Он устанавливает в поле matrix
следующий кадр анимации, если это возможно. Также расширим функционал метода draw, переопределив его таким образом,
что бы он вызвал метод суперкласса для отрисовки и метод nextFrame для смены кадров анимации.


Требования:
1.	В классе Ship должен существовать публичный метод void nextFrame().
2.	В методе nextFrame() поле frameIndex необходимо увеличить на единицу.
3.	Метод nextFrame() не должен ничего делать, если значение frameIndex больше либо равно количеству фреймов в списке frames.
4.	В методе nextFrame() полю matrix необходимо присвоить фрейм из списка frames с индексом frameIndex.
5.	В классе Ship должен быть переопределен метод родительского класса void draw(Game).
6.	Метод draw(Game game) класса Ship должен вызвать метод суперкласса с параметром game.
7.	Метод draw(Game game) класса Ship должен вызвать метод nextFrame().
8.	В классе Ship должен быть импорт класса com.javarush.engine.cell.Game.


Игра Space Invaders (20/34)

Реализуем &quot;убийство&quot; игрока, переопределив метод kill(). Помимо установки флага isAlive в состояние false,
он будет добавлять анимацию уничтожения корабля.



Игра Space Invaders (20/34)

На данном этапе мы подготовим анимацию для крушения кораблей. Для этого нам понадобится поле frames типа List&lt;int[][]&gt;,
которое будет хранить список матриц для кадров анимации. Также нам понадобится поле frameIndex, которое хранит индекс
текущего кадра анимации. Передавать кадры анимации мы будем в методе setAnimatedView. Он принимает массив
кадров(матриц) и передает их списку frames. В завершение, реализуем метод setStaticView, который задает изначальную матрицу
для кораблей.



Игра Space Invaders (20/34)

Добавим в класс PlayerShip метод, который проверяет, попали ли вражеские пули в корабль игрока (метод isCollision класса GameObject).
Если было попадание, он &quot;убивает&quot; корабль и пулю. Также добавим корабль игрока в класс игры, отрисуем его и внесем проверку попаданий в соответствующий метод.



Игра Space Invaders (20/34)

Теперь создадим корабль игрока. Для этого нам нужен класс PlayerShip. В его конструкторе
будем устанавливать значения координат таким образом, чтобы корабль отображался внизу экрана по центру.
Кроме этого, конструктор задает внешний вид корабля, устанавливая матрицу PLAYER, которую
мы тебе прислали в классе ShapeMatrix. У корабля может быть два состояния: &quot;живой&quot; или &quot;неживой&quot;
Чтобы описать эти состояния, добавим поле isAlive в общий класс кораблей Ship. Когда пуля попадает в корабль,
они (пуля и корабль) уничтожаются, поэтому добавим метод kill. При его вызове будем &quot;убивать&quot;
корабль и пулю.



Игра Space Invaders (20/34)

Все вражеские пули будем хранить в переменной enemyBullets класса SpaceInvadersGame. Добавим их отрисовку
и движение в соответствующие методы. Чтобы удалить потраченные пули, создадим и реализуем
метод removeDeadBullets() в классе SpaceInvadersGame. Для удаления можно либо использовать итератор, либо создать копию списка enemyBullets
и проходить по ней циклом. Если в результате проверки объект нужно удалить из списка, вызываем enemyBullets.remove(bullet).
К потраченным пулям относятся те, которые вылетели за пределы экрана, и те, которые попали в цель (isAlive == false).
Добавим вспомогательный метод check(). На данном этапе он будет вызывать метод removeDeadBullets(). Впоследствии в нем
будут происходить различные проверки на каждом шаге игры.
С такой же частотой мы будем вызывать метод fire() у флота, при котором один из вражеских кораблей может выстрелить.
Если выстрел произошел, метод вернет пулю, которую нужно добавить в список.



