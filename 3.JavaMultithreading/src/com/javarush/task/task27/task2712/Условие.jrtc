taskKey="com.javarush.task.task27.task2712.big22"\n\nРесторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления,
и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда -
последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask - у нас Producer, т.к. производит заказы.
Cook - это Consumer, т.к. обрабатывает заказы.

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь LinkedBlockingQueue queue и сеттер в класс Cook, сразу после создания повара, используя созданный сеттер, установи ему
константу из п.1 в качестве значения для созданного поля.
3. Tablet - не должен быть Observable. Убери все зависимости.
4. В Tablet добавь поле-очередь LinkedBlockingQueue queue, создай сеттер для него и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
7. Сделай класс Cook таском(Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
8. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.
9. В методе main создай и запусти трэды на основании тасок Cook.


Требования:
1.	В классе Restaurant должно быть создано private final static поле ORDER_QUEUE типа LinkedBlockingQueue.
2.	В классе Cook должно быть создано private поле queue типа LinkedBlockingQueue и сеттер.
3.	В классе Tablet должно быть создано private поле queue типа LinkedBlockingQueue и сеттер.
4.	Класс Tablet не должен быть потомком класса Observable.
5.	Класс Cook должен поддерживать интерфейс Runnable.
6.	Общая логика приготовления заказов и показа рекламы должна быть сохранена.
7.	Класс OrderManager должен быть удален.


Ресторан(22)

Продолжаем фиксить баг.

Сейчас все заказы поступают в очередь, но не доходят до поваров.
Сделаем так, чтобы OrderManager находил любого свободного повара и отдавал ему заказ. Для реализации данной логики
нам понадобится демон-трэд. Он будет проверять наличие заказов в очереди, брать свободных поваров и отдавать им заказы.

Нам понадобится метод, который определит, занят повар или нет.
1. В классе Cook создай поле boolean busy с геттером.
2. В начале метода startCookingOrder поставь busy в true, а в конце метода в false.
3. В методе startCookingOrder сымитируй задержку при приготовлении блюда, поставь слип в 10-кратном размере от времени приготовления заказа.
Т.е. если заказ готовится 30 минут, то задержка будет 30*10 миллисекунд.
4. Чтобы получить список всех поваров, в классе StatisticManager добавь геттер для поля, которое заполняется в методе register(Cook cook).

5. В конструкторе OrderManager создай и запусти демон-трэд. Логика метода run:
каждые 10 миллисекунд проверять очередь. Если в очереди есть заказы, то найти свободных поваров и передать
им заказы (метод startCookingOrder), если нет свободных поваров или нет заказов в очереди, то ждать дальше.



Ресторан(22)

Фикс бага - планшет направляет свой заказ всем известным ему поварам.
Ожидаемое поведение: планшет направляет свой заказ в очередь, свободный повар берет заказы из очереди.

Есть два варианта реализации такого функционала:
1) Каждый планшет хранит ссылку на очередь и толкает в нее новый свой заказ.
2) Планшет толкает свой заказ в Observer, который хранит в себе ссылку на очередь. Observer заносит заказ в очередь.

Мы пойдем по второму пути.
1. В корне задачи-проекта создай класс OrderManager, который будет Observer для планшетов.
2. В классе OrderManager создай поле orderQueue типа LinkedBlockingQueue&lt;Order&gt;. В него складывай все заказы, поступающие в метод update.
3. Класс Cook теперь - НЕ Observer.
4. В классе Cook создай метод void startCookingOrder(Order order), в который перенеси логику из метода update.
5. Удали метод update из класса Cook.
6. В методе main расставь зависимость Observer-Observable в связи с вышеперечисленными изменениями.



Ресторан(22)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Должно быть вот так:
public RandomOrderGeneratorTask(List&lt;Tablet&gt; tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для обоих поваров и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируй его в цикле.
6. Создай и запусти трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!



Ресторан(22)

Сейчас у нас один планшет и 1 повар.
Давай создадим несколько планшетов, которые будут рандомно генерировать заказы, и сделаем два повара.

1. В классе Restaurant создай ПРИВАТНУЮ статическую константу int ORDER_CREATING_INTERVAL = 100.

2. В отдельном классе создай таск(Runnable) RandomOrderGeneratorTask. Этот таск должен:
2.1. Хранить список всех планшетов.
2.2. Используя Math.random выбирать случайный планшет.
2.3. У RandomOrderGeneratorTask должен быть только один единственный метод.
2.4. Генерировать случайный заказ каждые ORDER_CREATING_INTERVAL миллисекунд для планшета из п.2.2 (не печатай стек-трейс).
Сейчас заказ создается в методе createOrder в классе Tablet.
В классе Tablet создай метод void createTestOrder() с похожей функциональностью,
который будет случайным образом генерировать заказ со случайными блюдами не общаясь с реальным человеком.
Список планшетов и интервал передай в конструкторе RandomOrderGeneratorTask.
Подсказка:
а) создай класс TestOrder - наследник Order - в пакете родителя;
б) в классе Order создай protected метод initDishes(), в котором инициализируй dishes. Вызови этот метод в конструкторе;
в) проверь, что в классе Order поле dishes имеет модификатор доступа protected;
г) переопредели initDishes в классе-наследнике TestOrder: проинициализируй поле dishes пустым списком и заполни его случайным набором блюд;
д) вместо создания объекта Order в методе createTestOrder() класса Tablet, создавай объект класса TestOrder.
Остальной функционал метода createTestOrder оставь таким же как в createOrder.

3. Отрефакторь методы createTestOrder() и createOrder(): в одном из методов выдели код, который повторяется в обоих методах,
и нажми Ctrl+Alt+M, введи любое имя метода и нажми ОК. IDEA предложит заменить этот код во втором методе, подтверди.



Ресторан(22)

Реализуем третий и четвертый пункт статистики - список активных и неактивных роликов.
Для этого проще использовать доступ к хранилищу рекламных роликов - класс AdvertisementStorage.
1. В пакете ad создай StatisticAdvertisementManager, который будет предоставлять информацию из AdvertisementStorage в нужном нам виде.
Сделай его синглтоном.

2. В классе StatisticAdvertisementManager создай и проинициализируй поле типа AdvertisementStorage.

3. В StatisticAdvertisementManager создай два(или один) метода (придумать самостоятельно), которые из хранилища
AdvertisementStorage достанут все необходимые данные - соответственно список активных и неактивных рекламных роликов.
Активным роликом считается тот, у которого есть минимум один доступный показ.
Неактивным роликом считается тот, у которого количество показов равно 0.

4. Реализуй логику методов printActiveVideoSet и printArchivedVideoSet в классе DirectorTablet.
Используй методы/метод, созданные в предыдущем пункте.
Сортировать по имени видео-ролика в алфавитном порядке без учета регистра.
Сначала английские, потом русские.

Пример вывода для printActiveVideoSet (имя ролика - оставшееся количество показов ролика):
First Video - 100
Second video - 10
Third Video - 2
четвертое видео - 4

Пример вывода для printArchivedVideoSet (имена роликов с количеством показов 0):
Second video
Third Video
четвертое видео



