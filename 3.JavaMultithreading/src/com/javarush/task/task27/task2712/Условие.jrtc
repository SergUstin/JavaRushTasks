taskKey="com.javarush.task.task27.task2712.big20"\n\nРесторан(20)

Фикс бага - планшет направляет свой заказ всем известным ему поварам.
Ожидаемое поведение: планшет направляет свой заказ в очередь, свободный повар берет заказы из очереди.

Есть два варианта реализации такого функционала:
1) Каждый планшет хранит ссылку на очередь и толкает в нее новый свой заказ.
2) Планшет толкает свой заказ в Observer, который хранит в себе ссылку на очередь. Observer заносит заказ в очередь.

Мы пойдем по второму пути.
1. В корне задачи-проекта создай класс OrderManager, который будет Observer для планшетов.
2. В классе OrderManager создай поле orderQueue типа LinkedBlockingQueue&lt;Order&gt;. В него складывай все заказы, поступающие в метод update.
3. Класс Cook теперь - НЕ Observer.
4. В классе Cook создай метод void startCookingOrder(Order order), в который перенеси логику из метода update.
5. Удали метод update из класса Cook.
6. В методе main расставь зависимость Observer-Observable в связи с вышеперечисленными изменениями.


Требования:
1.	Класс OrderManager должен поддерживать интерфейс Observer.
2.	Заказы поступающие в OrderManager должны добавляться в очередь orderQueue.
3.	Класс Cook не должен поддерживать интерфейс Observer.
4.	В классе Cook должен быть метод public void startCookingOrder(Order order).
5.	Из класса Cook должен быть удален метод update.


Ресторан(20)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Должно быть вот так:
public RandomOrderGeneratorTask(List&lt;Tablet&gt; tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для обоих поваров и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируй его в цикле.
6. Создай и запусти трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!



Ресторан(20)

Сейчас у нас один планшет и 1 повар.
Давай создадим несколько планшетов, которые будут рандомно генерировать заказы, и сделаем два повара.

1. В классе Restaurant создай ПРИВАТНУЮ статическую константу int ORDER_CREATING_INTERVAL = 100.

2. В отдельном классе создай таск(Runnable) RandomOrderGeneratorTask. Этот таск должен:
2.1. Хранить список всех планшетов.
2.2. Используя Math.random выбирать случайный планшет.
2.3. У RandomOrderGeneratorTask должен быть только один единственный метод.
2.4. Генерировать случайный заказ каждые ORDER_CREATING_INTERVAL миллисекунд для планшета из п.2.2 (не печатай стек-трейс).
Сейчас заказ создается в методе createOrder в классе Tablet.
В классе Tablet создай метод void createTestOrder() с похожей функциональностью,
который будет случайным образом генерировать заказ со случайными блюдами не общаясь с реальным человеком.
Список планшетов и интервал передай в конструкторе RandomOrderGeneratorTask.
Подсказка:
а) создай класс TestOrder - наследник Order - в пакете родителя;
б) в классе Order создай protected метод initDishes(), в котором инициализируй dishes. Вызови этот метод в конструкторе;
в) проверь, что в классе Order поле dishes имеет модификатор доступа protected;
г) переопредели initDishes в классе-наследнике TestOrder: проинициализируй поле dishes пустым списком и заполни его случайным набором блюд;
д) вместо создания объекта Order в методе createTestOrder() класса Tablet, создавай объект класса TestOrder.
Остальной функционал метода createTestOrder оставь таким же как в createOrder.

3. Отрефакторь методы createTestOrder() и createOrder(): в одном из методов выдели код, который повторяется в обоих методах,
и нажми Ctrl+Alt+M, введи любое имя метода и нажми ОК. IDEA предложит заменить этот код во втором методе, подтверди.



Ресторан(20)

Реализуем третий и четвертый пункт статистики - список активных и неактивных роликов.
Для этого проще использовать доступ к хранилищу рекламных роликов - класс AdvertisementStorage.
1. В пакете ad создай StatisticAdvertisementManager, который будет предоставлять информацию из AdvertisementStorage в нужном нам виде.
Сделай его синглтоном.

2. В классе StatisticAdvertisementManager создай и проинициализируй поле типа AdvertisementStorage.

3. В StatisticAdvertisementManager создай два(или один) метода (придумать самостоятельно), которые из хранилища
AdvertisementStorage достанут все необходимые данные - соответственно список активных и неактивных рекламных роликов.
Активным роликом считается тот, у которого есть минимум один доступный показ.
Неактивным роликом считается тот, у которого количество показов равно 0.

4. Реализуй логику методов printActiveVideoSet и printArchivedVideoSet в классе DirectorTablet.
Используй методы/метод, созданные в предыдущем пункте.
Сортировать по имени видео-ролика в алфавитном порядке без учета регистра.
Сначала английские, потом русские.

Пример вывода для printActiveVideoSet (имя ролика - оставшееся количество показов ролика):
First Video - 100
Second video - 10
Third Video - 2
четвертое видео - 4

Пример вывода для printArchivedVideoSet (имена роликов с количеством показов 0):
Second video
Third Video
четвертое видео



Ресторан(20)

Реализуем первый пункт статистики - какую сумму заработали на рекламе, сгруппировать по дням.

1. В классе VideoSelectedEventDataRow создай геттер для поля amount.
В классе CookedOrderEventDataRow создай геттер для поля cookName.

2. В StatisticManager создай метод (придумать самостоятельно), который из хранилища достанет все данные,
относящиеся к отображению рекламы, и посчитает общую прибыль за каждый день.
Дополнительно добавь вспомогательный метод get в класс хранилища, чтобы получить доступ к данным.

3. Начнем с логики метода printAdvertisementProfit в классе DirectorTablet.
Используя метод из предыдущего пункта вывести в консоль в убывающем порядке даты и суммы.
Для каждой даты из хранилища событий, для которой есть показанная реклама, должна выводится сумма прибыли за показы рекламы для этой даты.
В конце вывести слово Total и общую сумму.
Пример:
14-Jul-2013 - 2.50
13-Jul-2013 - 1.02
12-Jul-2013 - 543.98
Total - 547.50

4.Реализуем второй пункт статистики - загрузка (рабочее время) повара, сгруппировать по дням.

В StatisticManager создай метод (придумать самостоятельно), который из хранилища достанет все данные,
относящиеся к работе повара, и посчитает общую продолжительность работы для каждого повара отдельно.

5. Реализуем логику метода printCookWorkloading в классе DirectorTablet.
Используя метод из предыдущего пункта вывести в консоль в убывающем порядке даты, имена поваров и время работы в минутах (округлить в большую сторону).
Для каждой даты из хранилища событий, для которой есть запись о работе повара, должна выводится продолжительность работы в минутах для этой даты.
Если повар не работал в какой-то из дней, то с пустыми данными его НЕ выводить (см. 13-Jul-2013)
Поваров сортировать по имени
Пример:
14-Jul-2013
Ivanov - 60 min
Petrov - 35 min

13-Jul-2013
Ivanov - 129 min

12-Jul-2013
Ivanov - 6 min
Petrov - 5 min

6. Обрати внимание, что при выводе даты, название месяца должно быть на английском (при форматировании можно передать параметр Locale.ENGLISH).



Ресторан(20)

Давай подумаем что нужно сделать, чтобы директор мог посмотреть:
1) какую сумму заработали на рекламе, сгруппировать по дням;
2) загрузка (рабочее время) повара, сгруппировать по дням;
3) список активных роликов и оставшееся количество показов по каждому;
4) список неактивных роликов (с оставшемся количеством показов равным нулю).

Для каждого пункта добавим соответствующий метод в StatisticManager.
Директор будет вызывать метод, StatisticManager будет делать различные подсчеты.
Но директор должен из какого-то места вызвать эти методы. Дадим ему планшет, но с другим ПО.
Для этого создадим класс DirectorTablet, в котором будут дружелюбный интерфейс и возможность обращения к статистике.

1. В корне задачи-проекта создай класс DirectorTablet.

2. В классе DirectorTablet создай четыре void метода:
printAdvertisementProfit(), printCookWorkloading(), printActiveVideoSet(), printArchivedVideoSet()
Они соответствуют перечисленным четырем пунктам.

3. Чтобы можно было проверить результат, добавим в метод main создание директорского планшета и вывод статистики
с помощью методов перечисленных выше.

Нам понадобятся еще некоторые методы.
4. В EventDataRow создай методы:
- Date getDate(), реализация которого вернет дату создания записи
- int getTime(), реализация которого вернет время или продолжительность

5. В StatisticManager void register(Cook cook), который зарегистрирует полученного повара.
Создай в классе StatisticManager множество (Set) поваров (cooks) и добавь в него повара.

6. Реализуй необходимые геттеры у классов CookedOrderEventDataRow, NoAvailableVideoEventDataRow и VideoSelectedEventDataRow.



