taskKey="com.javarush.task.task35.task3513.big15"\n\n2048 (15)

Для того, чтобы эффективности различных ходов можно было сравнивать, необходимо реализовать в классе
MoveEfficiency поддержку интерфейса Comparable&lt;MoveEfficiency&gt;.

В методе compareTo первым делом сравни количество пустых плиток (numberOfEmptyTiles), потом счет (score),
если количество пустых плиток равное. Если и счет окажется равным, будем считать эффективность ходов
равной и вернем ноль.

Далее перейдем в класс Model и реализуем два метода:
1) boolean hasBoardChanged - будет возвращать true, в случае, если вес плиток в массиве gameTiles
отличается от веса плиток в верхнем массиве стека previousStates. Обрати внимание на то, что мы
не должны удалять из стека верхний элемент, используй метод peek.
2) MoveEfficiency getMoveEfficiency(Move move) - принимает один параметр типа move, и возвращает
объект типа MoveEfficiency описывающий эффективность переданного хода. Несколько советов:
а) не забудь вызывать метод rollback, чтобы восстановить корректное игровое состояние;
б) в случае, если ход не меняет состояние игрового поля, количество пустых плиток и счет у объекта MoveEfficiency
сделай равными -1 и 0 соответственно;
в) выполнить ход можно вызвав метод move на объекте полученном в качестве параметра.


Требования:
1.	Класс MoveEfficiency должен поддерживать интерфейс Comparable&lt;MoveEfficiency&gt;.
2.	Метод compareTo должен корректно сравнивать два объекта типа MoveEfficiency.
3.	Метод hasBoardChanged должен быть реализован в соответствии с условием задачи.
4.	Метод getMoveEfficiency должен возвращать эффективность хода полученного в качестве параметра.
5.	Если ход, переданный в метод getMoveEfficiency не меняет игровое поле, должен быть возвращен объект с количеством пустых клеток равным -1.
6.	Метод getMoveEfficiency не должен менять вес плиток в массиве gameTiles и счет.


2048 (15)

Случайный ход конечно неплох, но намного круче реализовать возможность умного хода. В дебри нейронных сетей
мы заходить не будем, для начала сконцентрируемся на достаточно простой идее.

Очевидно, хороший ход должен в итоге приближать нас к победе, а именно к получению плитки 2048.
Предлагаю рассмотреть такой вариант сравнения эффективности хода:
1) Первый ход является лучше второго, если после его совершения на поле находится больше пустых плиток,
чем в результате второго хода.
2) Первый ход является лучше второго, если общий счет после его совершения больше, чем счет
полученный в результате второго хода.

Для того, чтобы реализовать такое сравнение, мы можем совершить ход, оценить его эффективность и потом
отменить совершенный ход, чтобы вернуть игру в начальное состояние. Применив эту последовательность действий
ко всем четырем вариантам хода, сможем выбрать наиболее эффективный ход и выполнить его.

Концептуально, нам понадобятся два класса, один будет описывать ход, а другой эффективность хода.

Создай интерфейс Move с одним void методом move. Отметь интерфейс аннотацией @FunctionalInterface, которая
будет сигнализировать о том что в этом интерфейсе будет только один абстрактный метод.

Создай класс MoveEfficiency, описывающий эффективность хода. В нем нам понадобятся приватные поля
numberOfEmptyTiles и score типа int, а также приватное поле поле move типа Move.
В классе MoveEfficiency необходим конструктор с тремя параметрами (int numberOfEmptyTiles, int score, Move move)
для инициализации полей класса и геттер для поля move.



2048 (15)

Твой прогресс впечатляет! Для разнообразия, предлагаю дать игре возможность самостоятельно
выбирать следующий ход.

Начнем с простого, реализуем метод randomMove в классе Model, который будет вызывать один из методов движения
случайным образом. Можешь реализовать это вычислив целочисленное n = ((int) (Math.random() * 100)) % 4.
Это число будет содержать целое псевдослучайное число в диапазоне [0..3], по каждому из которых можешь вызывать
один из методов left, right, up, down.

Не забудь добавить в метод keyPressed класса Controller вызов метода randomMove по нажатию на клавишу R
(код - KeyEvent.VK_R).

P.S. Проверку корректности работы метода randomMove оставляю полностью под твою ответственность,
проверю только наличие вызова метода Math.random().



2048 (15)

Ну что, попробуем наш алгоритм в действии? Осталось добавить сохранение игрового состояния в начало каждого
метода движения, а также еще один кейс для обработки клавиши, которой будем выполнять отмену последнего хода.

При сохранении текущего состояния в стек, обрати внимание на то, чтобы всегда сохранялось актуальное состояние
и только однажды. Если ты послушал мой совет и реализовал методы right, up, down с помощью поворотов и вызова
метода left, можешь использовать следующий подход:
1) В самом начале методов right, up, down вызываем метод saveState с gameTiles в качестве параметра.
2) В методе left организуем проверку того, вызывался ли уже метод saveState. За это у нас отвечает
флаг isSaveNeeded, соответственно, если он равен true, выполняем сохранение. После выполнения
сдвига влево устанавливаем флаг isSaveNeeded равным true.

Также добавим в метод keyPressed класса Controller вызов метода rollback по нажатию на клавишу Z (код - KeyEvent.VK_Z).



2048 (15)

Отличная работа! На этом этапе у нас уже есть полнофункциональное приложение, но ведь нет предела совершенству,
давай еще поработаем.

Если ты успел какое-то время поиграть в 2048, то заметил, что порой очень хочется иметь возможность отменить
последний ход.

Давай создадим в классе Model два стека, в одном будем хранить предыдущие состояния игрового поля, а в другом
предыдущие счета. Назовем их previousStates и previousScores. Инициализировать можешь прямо в строке объявления
или в конструкторе. Используй стандартную реализацию стека (java.util.Stack).

Добавим boolean поле isSaveNeeded = true, оно нам понадобится в будущем.

Хранилище состояний у нас есть, теперь реализуем два метода для работы с ними.
1. Приватный метод saveState с одним параметром типа Tile[][] будет сохранять текущее
игровое состояние и счет в стеки с помощью метода push и устанавливать флаг isSaveNeeded равным false.
2. Публичный метод rollback будет устанавливать текущее игровое состояние равным последнему находящемуся
в стеках с помощью метода pop.

Обрати внимание на то, что при сохранении массива gameTiles необходимо создать новый массив и заполнить его
новыми объектами типа Tile перед сохранением в стек.

В методе rollback достаточно просто выполнить присваивание (gameTiles = previousStates.pop()) и то же для счета,
нет необходимости в глубоком копировании.

Перед восстановлением игрового состояния с помощью метода rollback не забудь проверить что стеки не пусты,
чтобы избежать возникновения исключения EmptyStackException.



2048 (15)

Пора приступить к реализации метода main в классе Main, чтобы иметь возможность наконец-то запустить игру и отдохнуть!

Метод main нам нужен только для того чтобы запустить приложение, все внутренности мы уже реализовали.
Для этого мы создадим в нем модель и контроллер, а также объект типа JFrame. Для примера я назову его game,
но ты можешь выбрать любое другое имя.

У нашей игры (объекта типа JFrame) мы должны будем вызвать некоторые методы для того чтобы все корректно отображалось
на экране:

game.setTitle(&quot;2048&quot;);
game.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
game.setSize(450, 500);
game.setResizable(false);

game.add(controller.getView());

game.setLocationRelativeTo(null);
game.setVisible(true);

Обрати внимание на метод add в который мы передаем представление из контроллера. У нас еще нет геттера для поля view
в классе Controller. Не забудь его добавить.

P.S. Результатом выполнения этого задания будет рабочая версия игры 2048, если у тебя вдруг что-то не работает,
или работает не так как ожидалось, обязательно разберись и исправь прежде чем переходить к следующим задачам.



