taskKey="com.javarush.task.task35.task3513.big14"\n\n2048 (14)

Случайный ход конечно неплох, но намного круче реализовать возможность умного хода. В дебри нейронных сетей
мы заходить не будем, для начала сконцентрируемся на достаточно простой идее.

Очевидно, хороший ход должен в итоге приближать нас к победе, а именно к получению плитки 2048.
Предлагаю рассмотреть такой вариант сравнения эффективности хода:
1) Первый ход является лучше второго, если после его совершения на поле находится больше пустых плиток,
чем в результате второго хода.
2) Первый ход является лучше второго, если общий счет после его совершения больше, чем счет
полученный в результате второго хода.

Для того, чтобы реализовать такое сравнение, мы можем совершить ход, оценить его эффективность и потом
отменить совершенный ход, чтобы вернуть игру в начальное состояние. Применив эту последовательность действий
ко всем четырем вариантам хода, сможем выбрать наиболее эффективный ход и выполнить его.

Концептуально, нам понадобятся два класса, один будет описывать ход, а другой эффективность хода.

Создай интерфейс Move с одним void методом move. Отметь интерфейс аннотацией @FunctionalInterface, которая
будет сигнализировать о том что в этом интерфейсе будет только один абстрактный метод.

Создай класс MoveEfficiency, описывающий эффективность хода. В нем нам понадобятся приватные поля
numberOfEmptyTiles и score типа int, а также приватное поле поле move типа Move.
В классе MoveEfficiency необходим конструктор с тремя параметрами (int numberOfEmptyTiles, int score, Move move)
для инициализации полей класса и геттер для поля move.


Требования:
1.	В интерфейсе Move должен присутствовать один абстрактный void метод move.
2.	Интерфейс Move должен быть отмечен аннотацией @FunctionalInterface.
3.	Конструктор класса MoveEfficiency должен корректно инициализировать поля класса.
4.	В классе MoveEfficiency должен быть создан корректный геттер для поля move.


2048 (14)

Твой прогресс впечатляет! Для разнообразия, предлагаю дать игре возможность самостоятельно
выбирать следующий ход.

Начнем с простого, реализуем метод randomMove в классе Model, который будет вызывать один из методов движения
случайным образом. Можешь реализовать это вычислив целочисленное n = ((int) (Math.random() * 100)) % 4.
Это число будет содержать целое псевдослучайное число в диапазоне [0..3], по каждому из которых можешь вызывать
один из методов left, right, up, down.

Не забудь добавить в метод keyPressed класса Controller вызов метода randomMove по нажатию на клавишу R
(код - KeyEvent.VK_R).

P.S. Проверку корректности работы метода randomMove оставляю полностью под твою ответственность,
проверю только наличие вызова метода Math.random().



2048 (14)

Ну что, попробуем наш алгоритм в действии? Осталось добавить сохранение игрового состояния в начало каждого
метода движения, а также еще один кейс для обработки клавиши, которой будем выполнять отмену последнего хода.

При сохранении текущего состояния в стек, обрати внимание на то, чтобы всегда сохранялось актуальное состояние
и только однажды. Если ты послушал мой совет и реализовал методы right, up, down с помощью поворотов и вызова
метода left, можешь использовать следующий подход:
1) В самом начале методов right, up, down вызываем метод saveState с gameTiles в качестве параметра.
2) В методе left организуем проверку того, вызывался ли уже метод saveState. За это у нас отвечает
флаг isSaveNeeded, соответственно, если он равен true, выполняем сохранение. После выполнения
сдвига влево устанавливаем флаг isSaveNeeded равным true.

Также добавим в метод keyPressed класса Controller вызов метода rollback по нажатию на клавишу Z (код - KeyEvent.VK_Z).



2048 (14)

Отличная работа! На этом этапе у нас уже есть полнофункциональное приложение, но ведь нет предела совершенству,
давай еще поработаем.

Если ты успел какое-то время поиграть в 2048, то заметил, что порой очень хочется иметь возможность отменить
последний ход.

Давай создадим в классе Model два стека, в одном будем хранить предыдущие состояния игрового поля, а в другом
предыдущие счета. Назовем их previousStates и previousScores. Инициализировать можешь прямо в строке объявления
или в конструкторе. Используй стандартную реализацию стека (java.util.Stack).

Добавим boolean поле isSaveNeeded = true, оно нам понадобится в будущем.

Хранилище состояний у нас есть, теперь реализуем два метода для работы с ними.
1. Приватный метод saveState с одним параметром типа Tile[][] будет сохранять текущее
игровое состояние и счет в стеки с помощью метода push и устанавливать флаг isSaveNeeded равным false.
2. Публичный метод rollback будет устанавливать текущее игровое состояние равным последнему находящемуся
в стеках с помощью метода pop.

Обрати внимание на то, что при сохранении массива gameTiles необходимо создать новый массив и заполнить его
новыми объектами типа Tile перед сохранением в стек.

В методе rollback достаточно просто выполнить присваивание (gameTiles = previousStates.pop()) и то же для счета,
нет необходимости в глубоком копировании.

Перед восстановлением игрового состояния с помощью метода rollback не забудь проверить что стеки не пусты,
чтобы избежать возникновения исключения EmptyStackException.



2048 (14)

Пора приступить к реализации метода main в классе Main, чтобы иметь возможность наконец-то запустить игру и отдохнуть!

Метод main нам нужен только для того чтобы запустить приложение, все внутренности мы уже реализовали.
Для этого мы создадим в нем модель и контроллер, а также объект типа JFrame. Для примера я назову его game,
но ты можешь выбрать любое другое имя.

У нашей игры (объекта типа JFrame) мы должны будем вызвать некоторые методы для того чтобы все корректно отображалось
на экране:

game.setTitle(&quot;2048&quot;);
game.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
game.setSize(450, 500);
game.setResizable(false);

game.add(controller.getView());

game.setLocationRelativeTo(null);
game.setVisible(true);

Обрати внимание на метод add в который мы передаем представление из контроллера. У нас еще нет геттера для поля view
в классе Controller. Не забудь его добавить.

P.S. Результатом выполнения этого задания будет рабочая версия игры 2048, если у тебя вдруг что-то не работает,
или работает не так как ожидалось, обязательно разберись и исправь прежде чем переходить к следующим задачам.



2048 (14)

Ты отлично справляешься! Так хорошо, что я решил тебе немного помочь и уже реализовал класс View.
Он достаточно прост. Наследуемся от класса JPanel, переопределяем метод paint и выводим на экран
текущее состояние модели, полученное через контроллер.

Тебе же, предстоит закончить реализацию класса Controller.

Для начала нам понадобится конструктор, он будет принимать один параметр типа Model, инициализировать поле
model, а также сохранять в поле view новый объект типа View с текущим контроллером(this) в качестве параметра
конструктора.

Далее, нам нужен метод resetGame, который позволит вернуть игровое поле в начальное состояние.
Необходимо обнулить счет, установить флаги isGameWon и isGameLost у представления в false и вызывать метод
resetGameTiles у модели. Примечание: устанавливай значение полей напрямую, без использования сеттеров.

Добавим приватную константу int WINNING_TILE = 2048. Она будет определять вес плитки при достижении которого
игра будет считаться выигранной.

Ну а теперь, самое главное! Для того чтобы иметь возможность обрабатывать пользовательский ввод, необходимо
переопределить метод keyPressed с одним параметром типа KeyEvent.
Логика метода должна быть следующей:
1) Если была нажата клавиша ESC - вызови метод resetGame.
2) Если метод canMove модели возвращает false - установи флаг isGameLost в true.
3) Если оба флага isGameLost и isGameWon равны false - обработай варианты движения:
а) для клавиши KeyEvent.VK_LEFT вызови метод left у модели;
б) для клавиши KeyEvent.VK_RIGHT вызови метод right у модели;
в) для клавиши KeyEvent.VK_UP вызови метод up у модели;
г) для клавиши KeyEvent.VK_DOWN вызови метод down у модели.
4) Если поле maxTile у модели стало равно WINNING_TILE, установи флаг isGameWon в true.
5) В самом конце, вызови метод repaint у view.

P.S. Для получения кода нажатой клавиши используй метод getKeyCode класса KeyEvent.



